#!/bin/sh
#
# Copyright 2014 iXsystems (Kris Moore)
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

usage_add_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -f             -- Force install, overwriting existing installation
  -i             -- Display information about this PBI
  -j <jail> 	 -- Install into jail
  -l             -- Display LICENSE text
  -v             -- Enable verbose output

EOF
        exit_trap
}

usage_delete_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -f             -- Force removing a PBI / package
  -j <jail> 	 -- Delete from jail
  -v             -- Enable verbose output

EOF
        exit_trap
}

usage_makeindex_pbi() {
        cat <<EOF
usage: `basename $0` [openssl key]

To build a PBI index file run 'makeindex' inside a modules directory,
along with the path to your openssl private key for signing. 

EOF

	exit_trap
}

usage_icon_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  add-desktop          -- Add desktop icons
  add-menu             -- Add menu icons
  add-mime             -- Add mime registration
  del-desktop          -- Remove desktop icons
  del-menu             -- Remove menu icons
  del-mime             -- Remove mime registration

EOF
        exit_trap
}

usage_info_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -a             -- Show all available PBIs
  -j <jail> 	 -- List packages from specified jail
  -v             -- Enable verbose output

EOF
        exit_trap
}

# Parse the command line for info
parse_delete_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -v)     PBI_VERBOSE="YES" 
                        ;;
                -f)     PBI_FORCEDELETE="YES" 
                        ;;
                -j)     shift
			set_jail_mode "$1"
                        ;;
                 *)     if [ $# -gt 1 ]; then usage_delete_pbi; fi
			load_pbi_info_index "$1"
			if [ $? -ne 0 ] ; then
				exit_err "No such PBI: $1"
			fi
                       	PBI_DELETENAME="$1"
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_DELETENAME}" ];then usage_delete_pbi; fi
}

# Parse the command line for icon
parse_icon_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                add-desktop)	PBI_DESKADD="YES" ;;
                add-menu)	PBI_MENUADD="YES" ;;
                add-mime)	PBI_MIMEADD="YES" ;;
                add-pathlnk)	PBI_PATHADD="YES" ;;
                del-desktop)	PBI_DESKDEL="YES" ;;
                del-menu)	PBI_MENUDEL="YES" ;;
                del-mime)	PBI_MIMEDEL="YES" ;;
                del-pathlnk)	PBI_PATHDEL="YES" ;;
                 *)
                        if [ $# -gt 1 ]; then usage_icon_pbi; fi

			# Load this PBI from INDEX
			load_pbi_info_index "$1"
			if [ $? -ne 0 ] ; then
				exit_err "No such PBI: $1"
			fi

			# Check if this PBI is installed
			is_pbi_installed "$PBI_ORIGIN"
			if [ $? -ne 0 ] ; then
				exit_err "PBI not installed: $1"
			fi
			
                       	PBI_ICONTARGETAPP="$1"
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_ICONTARGETAPP}" ] ; then 
		usage_icon_pbi
	fi
}

# Parse the command line for pbid
parse_pbid_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -v)     PBI_VERBOSE="YES" 
                        ;;
         --refresh)     # Schedule us to refresh the index
			echo "Your index files will begin refreshing in a moment..."
			echo "Details available in /var/log/pbid.log"
			rm ${PBI_DBINDEXDIR}.time >/dev/null 2>/dev/null
			if [ -e "${PROGBASE}/etc/rc.d/pbid" ]; then
			   ${PROGBASE}/etc/rc.d/pbid restart >/dev/null 2>/dev/null
			fi
			exit 0
                        ;;
		esac
		shift
	done
}

# Parse the command line for info
parse_info_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
		-a) 	PBI_INFOINDEX="YES"	
			;;
                -j)     shift
			set_jail_mode "$1"
                        ;;
                -v)     PBI_VERBOSE="YES" 
                        ;;
                 *)
                        if [ $# -gt 1 ]; then usage_info_pbi; fi
                        PBI_INFONAME="$1"
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_INFONAME}" ] ; then 
		PBI_INFONAME="--ALL--" 
	fi
}

# Parse the command line for adding
parse_add_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -e)     PBI_EXTRACTONLY="YES"
                        ;;
                -f)     PBI_FORCEADD="YES"
                        ;;
                -i)     PBI_ADD_INFODISPLAY="YES" 
                        ;;
                -j)     shift
			set_jail_mode "$1"
                        ;;
            --meta)     PBI_ADD_METADISPLAY="YES" 
                        ;;
                -l)     PBI_ADD_LICDISPLAY="YES" 
                        ;;
                -o)     if [ $# -eq 1 ]; then usage_add_pbi; fi
                        shift; PBI_ALTEXTRACT_DIR="$1"
                        ;;
                -v)     PBI_VERBOSE="YES" 
                        ;;
     --checkscript)     PBI_CHECKSCRIPTS="YES" ;;
        --licagree)     PBI_LICAGREE="YES" ;;
     --no-checksum)     PBI_SKIPCHECKSUM="YES" ;;
     --no-checksig)     PBI_SKIPSIGVERIFY="YES" ;;
                 *)
                        if [ $# -gt 1 ]; then usage_add_pbi; fi
                        PBI_FILENAME="$1"
                        ;;
                esac
                shift
        done

        if [ -z "${PBI_FILENAME}" ]; then usage_add_pbi ; fi
}

# Make sure this is a valid jail
set_jail_mode()
{
	# Check if this is a JID
	jls | grep -v "JID" | tr -s ' ' | sed 's,^[ \t]*,,' | grep -q "^$1 "
	if [ $? -eq 0 ] ; then
		PBI_INJAIL="$1"
		PKG_FLAG="-j $1"
		return
	fi
	
	# Is this a hostname?
	line=`jls | grep -v "JID" | tr -s ' ' | sed 's,^[ \t]*,,' | grep -w "$1" | head -n 1`
	if [ -n "$line" ] ; then
		PBI_INJAIL="`echo $line | awk '{print $1}'`"	
		PKG_FLAG="-j $PBI_INJAIL"
		PBI_INJAIL="$1"
		return
	fi

	exit_err "No such jail: $1"

}

# Make some of our required PBI dirs
mk_required_dirs() {
	if [ ! -d "${PBI_DBAPPDIR}" ] ; then mkdir -p ${PBI_DBAPPDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_DBINDEXDIR}" ] ; then mkdir -p ${PBI_DBINDEXDIR} >/dev/null 2>/dev/null ; fi

}

# Initialize some vars
init_vars() {

        # Where is pbi-manager installed?
        PROGBASE=/usr/local
	SYS_LOCALBASE=/usr/local
	PBI_SHARE_DIR="${PROGBASE}/share/pbi-manager"

	PBI_ETCCONF="${SYS_LOCALBASE}/etc/pbi.conf"
	PCBSD_ETCCONF="${SYS_LOCALBASE}/etc/pcbsd.conf"
	PBI_DEFAULT_ICON="${PROGBASE}/share/pbi-manager/icons/default.png"

	# Which ${PKG_CMD} command
	PKG_CMD="pkg ${PBI_PKGCFLAG}"

	# Set the PBI DB dir
	if [ -z "${PBI_DBDIR}" ] ; then
		PBI_DBDIR="/var/db/pbi"
	fi
	PBI_DBKEYDIR="${PBI_DBDIR}/keys"
	PROGVERSION="2.0"

	# Load the etc/pbi.conf file
	load_pbi_etcconf

	# Overrides from pbi.conf
	if [ -z "$PBIDSLEEP" ] ; then
		PBIDSLEEP="300"	# Amount of time to sleep before waking up pbid
	fi
	if [ -z "$PBI_INDEXREFRESH" ] ; then
		PBI_INDEXREFRESH="24" # Hours to wait until we re-download PBI indexes
	fi

	PBI_LOG_LINES="500"

	# Don't modify unless you know what your doing!
	MOD_PREINS="pre-install.sh"
	MOD_POSTINS="post-install.sh"
	MOD_PREREM="pre-remove.sh"
	MOD_XDGDESK_DIR="xdg-desktop"
	MOD_XDGMENU_DIR="xdg-menu"
	MOD_XDGMIME_DIR="xdg-mime"
	PBI_BUILD_USERS=""
	PBI_CONFFILE="pbi.conf"
	PBI_DESKADD="NO"
	PBI_MENUADD="NO"
	PBI_MIMEADD="NO"
	PBI_PATHADD="NO"
	PBI_DESKDEL="NO"
	PBI_MENUDEL="NO"
	PBI_MIMEDEL="NO"
	PBI_PATHDEL="NO"
	PBI_DELETENAME=""
	PBI_FILENAME=""
	PBI_FORCEADD="NO"
	PBI_INDEXFILE="PBI-INDEX.txz"
	PBI_INFONAME=""
	PBI_ICDIR="pbi-shared-icons"
	PBI_LICAGREE="NO"
	PBI_RESOURCE_DIR="resources"
	PBI_SSLPRIVKEY=""
	PBI_TMPDIR="/tmp/.PBI.$$"
	PBI_UPCHECK=""

        # User overridable variables
	PBI_DBINDEXDIR="${PBI_DBDIR}/index"
	PBI_INDEXDB="${PBI_DBINDEXDIR}/PBI-INDEX"
	PBI_VERBOSE="NO"
}

# init tmpdir
init_tmpdir() {
	if [ -d "${PBI_TMPDIR}" ] ; then return; fi
	if [ -z "${PBI_TMPDIR}" ] ; then return ; fi
	if [ "${PBI_TMPDIR}" = "/" ] ; then return ; fi
	if [ -e "${PBI_TMPDIR}" ] ; then rm -rf "${PBI_TMPDIR}" ; fi
	mkdir -p "${PBI_TMPDIR}"
}

# rm tmpdir
rm_tmpdir() {
	if [ -z "${PBI_TMPDIR}" -o "${PBI_TMPDIR}" = "/" ] ; then return 0; fi
	if [ -e "${PBI_TMPDIR}" ] ; then rm -rf "${PBI_TMPDIR}" ; fi
}

# Load PBI conf options
load_pbi_conffile() {
  	if [ ! -d "${PBI_CONFDIR}" ] ; then return 0 ; fi
  	if [ -e "${PBI_CONFDIR}/${PBI_CONFFILE}" ] ; then
		unset PBI_MAKEPORT PBI_BUILDKEY PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_PROGREVISION PBI_AB_NOPKGBUILD PBI_ORIGIN
		. ${PBI_CONFDIR}/${PBI_CONFFILE}

		# Remove any trailing '/' from PBI_MAKEPORT
		echo $PBI_ORIGIN | grep -q "/$"
		if [ $? -eq 0 ] ; then
			PBI_ORIGIN="`echo $PBI_ORIGIN | sed 's|/$||g'`"
		fi
	fi
}

# Helper function to exit after a error, and do some cleanup
exit_err() {
	echo -e "`basename ${0}`: ${1}"
	rm_tmpdir
	exit 255
}

# Confirm we are running as root
require_root() {
  if [ `id -u` != "0" ] ; then
     exit_err "Must be run as root!"
  fi 
}

# Create a PBI repoindex from a modules directory
pbi_makeindex_init() {
	# Make sure we have been given a signing key
	if [ -z "$1" -o ! -e "$1" ] ; then
		usage_makeindex_pbi
	fi

	# Create a new repoindex file
	make_pbi_index "$1"
}

# Create a PBI-INDEX file and save it, along with scripts to a .txz file
make_pbi_index() {

   sKey="$1"

   if [ ! -e "PBI-categories" ] ; then
      exit_err "No PBI-categories file.. Is this a modules directory?"
   fi

   # Update PKGNG repo
   ${PKG_CMD} update 2>/dev/null

   echo "Building PBI-INDEX... This may take a few moments..."
	
   # Set our delimiter and temp INDEX files
   d="::::"
   tI=".INDEX.$$"
   touch $tI

   for pbi in `find . -type f -name "${PBI_CONFFILE}" | grep -v '\.svn' | grep -v '\.git' | sort`
   do
	# Figure out the target port for this build
	unset PBI_MAKEPORT PBI_BUILDKEY PBI_PROGVERSION PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_AB_NOPKGBUILD PBI_SCREENSHOTS PBI_RELATED PBI_PLUGINS PBI_DESC PBI_SHORTDESC PBI_ORIGIN

	. ${pbi}

	_cd=$(dirname $pbi | sed 's|./||')
	PBI_CONFDIR="$_cd"

	# Make sure PBI_ORIGIN is set
	if [ -z "${PBI_ORIGIN}" ] ; then
		PBI_ORIGIN=`echo $pbi | sed 's|./||'`
		export PBI_ORIGIN
	fi	

  	# Remove any trailing '/'
  	echo $PBI_ORIGIN | grep -q "/$"
  	if [ $? -eq 0 ] ; then 
		PBI_ORIGIN="`echo $PBI_ORIGIN | sed 's|/$||g'`"
  	fi
	
	# Check for missing port target
	if [ -z "$PBI_ORIGIN" ] ; then
		echo "Warning: Missing PBI_ORIGIN for ${pbi}"
		continue
	fi

	# Make sure this PBI exists in the repo
	${PKG_CMD} rquery -U '%n' $PBI_ORIGIN >/dev/null 2>/dev/null
	if [ $? -ne 0 ] ; then 
		echo "Warning: Origin package missing for $PBI_CONFDIR ($PBI_ORIGIN)"
		continue
	fi

	# Git rid of extra spaces
	local _PKGOTHER=""

	# Check that all the other packages required are available
	skip=0
	for port in `echo ${PBI_OTHERPKGS} | awk 1 ORS=' '`
	do
  		# Cleanup $port
  		echo $port | grep -q "/$"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|/$||g'`"; fi
  		echo $port | grep -q "^/"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|^/||g'`"; fi

		${PKG_CMD} rquery -U '%v' ${port} >/dev/null 2>/dev/null
		if [ $? -ne 0 ] ; then
			echo "Warning: Required package missing for $PBI_CONFDIR ($port)"
			skip=1
			break
		fi
		_PKGOTHER="$_PKGOTHER $port"
	done
	if [ $skip -eq 1 ] ; then continue ; fi

	# Load any extra meta-data from the package
	load_pkg_metadata

	# Save this to the temporary INDEX file
	echo "PBI=${PBI_ORIGIN}${d}${PBI_PROGNAME}${d}${_PKGOTHER}${d}${PBI_PROGAUTHOR}${d}${PBI_PROGWEB}${d}${PBI_LICENSE}${d}${PBI_PROGTYPE}${d}${PBI_CATEGORY}${d}${PBI_TAGS}${d}${PBI_MAINTAINER}${d}${PBI_SHORTDESC}${d}${PBI_DESC}${d}${PBI_SCREENSHOTS}${d}${PBI_RELATED}${d}${PBI_PLUGINS}${d}${PBI_CONFDIR}${d}" >> ${tI}

   done

   # Add the categories data
   cat PBI-categories >> ${tI}

   # Move the temp index
   mv ${tI} PBI-INDEX

   # Create the .txz file
   echo "Compressing PBI-INDEX..."
   tar cvJf ${PBI_INDEXFILE} --exclude ./.git --exclude ./${PBI_INDEXFILE} . >/dev/null 2>/dev/null

   # Sign this INDEX file
   openssl dgst -sha1 \
	-sign ${sKey} \
	-out ${PBI_INDEXFILE}.sha1 \
	${PBI_INDEXFILE}
   if [ $? -ne 0 ] ; then
      echo "ERROR: Failed to sign PBI repo.."
      exit 1
   fi

   exit 0
}

# Lets check if this PBI exists in the indexdb
load_pbi_info_index()
{
	local tPBI="$1"
	d="::::"

	# No Database? Ain't gona find much..
	if [ ! -e "$PBI_INDEXDB" ] ; then return 1; fi
	
	# Search by name
	local line=`cat ${PBI_INDEXDB} | grep "^PBI=" | grep -i "${d}${tPBI}${d}" | head -n 1`
	if [ -z "$line" ] ; then
		# Not by name, search by ORIGIN
		line=`cat ${PBI_INDEXDB} | grep "^PBI=${tPBI}${d}" | head -n 1`
		if [ -z "$line" ] ; then return 1; fi
	fi

	# Now get values from this list
	PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
	PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
	PBI_ORIGIN=`echo $line | awk -F:::: '{print $1}' | sed 's|PBI=||g'`
	PBI_PKGOTHER=`echo $line | awk -F:::: '{print $3}'`
	PBI_PROGAUTHOR=`echo $line | awk -F:::: '{print $4}'`
	PBI_PROGWEB=`echo $line | awk -F:::: '{print $5}'`
	PBI_PROGLICENSE=`echo $line | awk -F:::: '{print $6}'`
	PBI_PROGTYPE=`echo $line | awk -F:::: '{print $7}'`
	PBI_PROGCAT=`echo $line | awk -F:::: '{print $8}'`
	PBI_PROGMAINT=`echo $line | awk -F:::: '{print $10}'`
	PBI_SHORTDESC=`echo $line | awk -F:::: '{print $11}'`
	PBI_DESC=`echo $line | awk -F:::: '{print $12}'`
	PBI_PLUGINS=`echo $line | awk -F:::: '{print $15}'`
	PBI_CONFDIR=`echo $line | awk -F:::: '{print $16}'`
	PBI_APPARCH=`uname -m`
	PBI_PROGVERSION=`${PKG_CMD} ${PKG_FLAG} rquery '%v' $PBI_ORIGIN`
	
	return 0
}

# Start the pbi_add process
pbi_add_init() {
	init_tmpdir
	parse_add_pbi_cmdline "$@"

	# If this isn't a container request, switch to package mode
	load_pbi_info_index "$PBI_FILENAME"
	if [ $? -ne 0 ] ; then
		exit_err "No such PBI: $PBI_FILENAME"
	fi
	if [ "$PBI_ADD_INFODISPLAY" = "YES" ] ; then
		check_pbi_info_display
		exit_trap
	fi
	do_pbi_pkg_add
	exit_trap
}

# Doing a PBI install via the package system
do_pbi_pkg_add() {
	echo "Installing: $PBI_FILENAME"

	# Make list of packages to install
	local _ins="$PBI_ORIGIN $PBI_PKGOTHER"
	local _toIns=""

	# See if this origin is already installed
	for i in $_ins
	do
		${PKG_CMD} ${PKG_FLAG} query '%n' $i >/dev/null 2>/dev/null
		if [ $? -eq 0 ] ; then continue ; fi
		
		# Not installed! Lets Add it to the list
		_toIns="$_toIns $i"
	done

	if [ -z "$_toIns" ] ; then
		exit_err "$PBI_FILENAME is already installed!"
	fi

	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Installing packages: $_toIns"
		dn=""	
	fi

	# Lets check for any conflicts doing this install
	check_pkg_conflicts "install -FUy ${_toIns}"
	if [ $? -ne 0 ] ; then
     		exit 1
  	fi

	# Now go forth and install these packages
	${PKG_CMD} ${PKG_FLAG} install -yUf ${_toIns}
	if [ $? -ne 0 ] ; then
		exit_err "Failed installing: $PBI_FILENAME"
	fi

	exit 0
}

# See if we need to display pbi info
check_pbi_info_display() {
	if [ "$PBI_ADD_INFODISPLAY" != "YES" ] ; then return 0 ; fi
	pbi_display_info
}

# Display pbi information to stdout
pbi_display_info() {

	tmp="`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`"
        _appname="${tmp}-${PBI_PROGVERSION}-${PBI_APPARCH}"

	echo "PBI Information for: $_appname"
	echo "-----------------------------------------------------"
	echo "Name: ${PBI_PROGNAME}"

	if [ -n "$PBI_INSTALLED_BY" ] ; then
		echo "InstalledBy: $PBI_INSTALLED_BY"
	fi

	echo "Version: ${PBI_PROGVERSION}"
	echo "Author: ${PBI_PROGAUTHOR}"
	echo "Website: ${PBI_PROGWEB}"
	echo "Arch: ${PBI_APPARCH}"
	echo "Description: ${PBI_SHORTDESC}"
	if [ -n "$PBI_LICENSE" ] ; then
		echo "License: $PBI_LICENSE"
	fi

	# See if we have any XDG stuff
	if [ -d "${PBI_DBINDEXDIR}/${PBI_CONFDIR}/xdg-desktop" ] ; then
		echo "DesktopIcons: YES"
	fi
	if [ -d "${PBI_DBINDEXDIR}/${PBI_CONFDIR}/xdg-menu" ] ; then
		echo "MenuIcons: YES"
	fi
	if [ -d "${PBI_DBINDEXDIR}/${PBI_CONFDIR}/xdg-mime" ] ; then
		echo "MimeRegistration: YES"
	fi
	echo ""
}

# Check if we have a postinstall script we need to use
check_postinstall_script() {
        open_header_tmp

        if [ ! -e "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}" ] ; then
                delete_header_tmp
                return 0
        fi

        sh "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}"
        delete_header_tmp
}

# Check if we have a preinstall script we need to use
check_preinstall_script() {
	open_header_tmp

	if [ ! -e "${PBI_HEADER_TMPDIR}/${MOD_PREINS}" ] ; then 
		delete_header_tmp
		return 0 
	fi

	sh "${PBI_HEADER_TMPDIR}/${MOD_PREINS}"
	if [ "$?" != "0" ] ; then
        	delete_header_tmp
		exit_err "${MOD_PREINS} returned error status"
	fi
        delete_header_tmp
}

# Check if we have valid signature on this file
check_file_sig() {
	good="true"
        openssl dgst -sha1 \
                      -verify ${PBI_SHARE_DIR}/repokey.ssl \
                      -signature ${1}.sha1 \
                      ${1} >/dev/null 2>/dev/null
	return $?	
}

pbi_delete_init() {
	init_tmpdir
	parse_delete_pbi_cmdline "$@"
	do_pbi_delete
}

# Delete this PBI
do_pbi_delete() {

	# First confirm this package is installed
	${PKG_CMD} ${PKG_FLAG} query '%n' $PBI_ORIGIN 2>/dev/null >/dev/null
	if [ $? -ne 0 ] ; then
		exit_err "$PBI_DELETENAME is not installed!"
	fi
	require_root
	
	if [ "$PBI_FORCEDELETE" = "YES" ] ; then
		pOpts="-y -f"
	else
		pOpts="-y"
	fi

	${PKG_CMD} ${PKG_FLAG} delete $pOpts -R $PBI_ORIGIN

	# Check if we can remove any plugins
	for i in $PBI_PLUGINS
	do
		${PKG_CMD} ${PKG_FLAG} delete ${pOpts} $i
		if [ $? -eq 0 ] ; then
			echo "WARNING: Did not remove optional plugin ${i}"
		fi
	done
	
	# Do any package autoremove cleanup
	${PKG_CMD} ${PKG_FLAG} autoremove -y
		
	exit_trap
}

# Check if we have a preinstall script we need to use
check_preremove_script() {
	if [ ! -e "${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}" ] ; then return 0 ; fi

	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Running pre-removal script: ${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}"
	fi
       	sh "${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}"
}

is_pbi_installed() {
	# check for pkgng version
	${PKG_CMD} ${PKG_FLAG} query '%n' $1 >/dev/null 2>/dev/null
	if [ $? -eq 0 ] ; then return 0; fi
	return 1
}

pbi_icon_init() {
	parse_icon_pbi_cmdline "$@"
	do_pbi_icon
}

# Start the PBI icon process
do_pbi_icon() {

        PBI_EXEDIR=""
	PBI_LAPPDIR="/usr/local/"

	# Add desktop / menu icons
	if [ "${PBI_DESKADD}" = "YES" ] ; then
		add_xdg_icon "$PBI_CONFDIR" "desktop"
	fi
	if [ "${PBI_DESKDEL}" = "YES" ] ; then
		del_xdg_icon "$PBI_CONFDIR" "desktop"
	fi
	if [ "${PBI_MENUADD}" = "YES" ] ; then
		add_xdg_icon "$PBI_CONFDIR" "menu"
	fi
	if [ "${PBI_MENUDEL}" = "YES" ] ; then
		del_xdg_icon "$PBI_CONFDIR" "menu"
	fi

	# Add mime types
	if [ "${PBI_MIMEADD}" = "YES" ] ; then
		add_xdg_icon "$PBI_CONFDIR" "mime"
	fi
	if [ "${PBI_MIMEDEL}" = "YES" ] ; then
		del_xdg_icon "$PBI_CONFDIR" "mime"
	fi

	exit_trap
}

del_xdg_icon() {

	local type="$2"
	case $type in
		desktop) subdir="xdg-desktop" 
			 cmd="xdg-desktop-icon"
			 ext="desktop"
			 ;;
		   menu) subdir="xdg-menu" 
			 cmd="xdg-desktop-menu"
			 ext="desktop"
			 ;;
		   mime) subdir="xdg-mime" 
			 cmd="xdg-mime"
			 ext="xml"
			 ;;
		      *) exit_err "Invalid xdg_icon()" ;;

	esac

	# Look for any .desktop files to remove
	for i in `ls ${PBI_DBINDEXDIR}/$1/$subdir/*.${ext} 2>/dev/null`
	do
		$cmd uninstall `basename $i`
	done
}

add_xdg_icon() {
	init_tmpdir

	local type="$2"
	case $type in
		desktop) subdir="xdg-desktop" 
			 cmd="xdg-desktop-icon"
			 ext="desktop"
			 ;;
		   menu) subdir="xdg-menu" 
			 cmd="xdg-desktop-menu"
			 ext="desktop"
			 ;;
		   mime) subdir="xdg-mime" 
			 cmd="xdg-mime"
			 ext="xml"
			 ;;
		      *) exit_err "Invalid xdg_icon()" ;;
	esac

	# See if we have any .desktop files to install
	for i in `ls ${PBI_DBINDEXDIR}/${1}/${subdir}/*.${ext} 2>/dev/null`
	do
		fNam=`basename $i`
		# Copy over the .desktop file, modifying any variables within
	        cat "${i}" \
           	| sed "s|%%PBI_EXEDIR%%/|${PBI_EXEDIR}|g" \
           	| sed "s|%%PBI_EXEDIR%%|${PBI_EXEDIR}|g" \
		| sed "s|%%PBI_APPDIR%%/|${PBI_LAPPDIR}|g" \
		| sed "s|%%PBI_APPDIR%%|${PBI_LAPPDIR}|g" \
		> "${PBI_TMPDIR}/${fNam}"

		# Fix icons
		check_xdg_icon "${PBI_TMPDIR}/${fNam}" "$1"

		# Set the correct permissions on the desktop file
		chmod 744 "${PBI_TMPDIR}/${fNam}"

		# Install the icon now
		$cmd install --novendor ${PBI_TMPDIR}/$fNam

		# Cleanup
		rm ${PBI_TMPDIR}/$fNam
	done

}

# 1 - .desktop file to check
# 2 - PBI_ORIGIN
check_xdg_icon() {
	local iPath=`grep "^Icon=" ${1} | sed 's|^Icon=||g'`
	local oPath="${iPath}"
	# Do we have an icon in this file?
	if [ -z "$iPath" ] ; then return ; fi
	# Does the icon exist?
	if [ -e "$iPath" ] ; then return ; fi

	# Do we have an icon in resources?
	if [ ! -e "${PBI_DBINDEXDIR}/$2/icon.png" ] ; then
		return
	fi

	# Update the location in the XDG file
	sed -i '' "s|^Icon=$oPath|Icon=${PBI_DBINDEXDIR}/$2/icon.png|g" ${1}
}

pbid_init() {
	require_root

	parse_pbid_cmdline "$@"

	do_pbid
}

# Start the PBID daemon
do_pbid() {

	# Start by sourcing /etc/profile
	# This grabs any HTTP_ / FTP_ PROXY variables
	. /etc/profile

	# Allow user supplied logfile
        if [ -z "${PBID_LOGFILE}" ] ; then
	  _pbid_log="/var/log/pbid.log"
	else
          _pbid_log="${PBID_LOGFILE}"
        fi

	# Set verbosity 
	_redir="&1"
	if [ "${PBI_VERBOSE}" != "YES" ] ; then _redir="/dev/null" ; fi
	echo "Started pbid: `date`" > ${_pbid_log}

	while
	i=1
	do
		# Do regular sleeps
		qslp=0

		# Check if we have any out of date index files to update
		check_update_index
		if [ $? -eq 1 ] ; then qslp=1; fi

		# Check if we should rotate the logfile
		_pbidLines=`wc -l ${_pbid_log} | awk '{ print $1 }'`
		if [ $(is_num "$_pbidLines") ] ; then
			if [ $_pbidLines -gt $PBI_LOG_LINES ] ; then
				echo "Logfile turnover: `date`" >${_pbid_log}
			fi
		fi
		

		# Done with our check, lets go back to sleep now
		if [ $qslp -eq 1 ] ; then
			sleep 10
		else
			sleep ${PBIDSLEEP}
		fi
	done

}

pbi_info_init() {
	parse_info_pbi_cmdline "$@"
	
	do_pbi_info
}

# Display information on the PBI / PBIs
do_pbi_info() {

	# No Database? Ain't gona find much..
	if [ ! -e "$PBI_INDEXDB" ] ; then return; fi

	# If we are listing available PBIs via the index file
	if [ "$PBI_INFOINDEX" = "YES" ] ; then
		
		# List the available PBIs from the index
		do_index_listing
		
		exit_trap
	fi

	if [ "$PBI_INFONAME" = "--ALL--" ] ; then
		# Next list package PBIs
		echo "PBIs installed into system"
		echo "-------------------------------"
		for pkgori in `${PKG_CMD} ${PKG_FLAG} query '%o'`
		do

			line=`grep "^PBI=${pkgori}::::" $PBI_INDEXDB`
			if [ -z "$line" ] ; then continue ; fi

			PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
			PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
			PBI_PROGVERSION=`${PKG_CMD} ${PKG_FLAG} query '%v' $pkgori`
			if [ "$PBI_VERBOSE" = "YES" ] ; then
				PBI_PKGOTHER=`echo $line | awk -F:::: '{print $3}'`
				PBI_PROGAUTHOR=`echo $line | awk -F:::: '{print $4}'`
				PBI_PROGWEB=`echo $line | awk -F:::: '{print $5}'`
				PBI_PROGLICENSE=`echo $line | awk -F:::: '{print $6}'`
				PBI_PROGTYPE=`echo $line | awk -F:::: '{print $7}'`
				PBI_PROGCAT=`echo $line | awk -F:::: '{print $8}'`
				PBI_PROGMAINT=`echo $line | awk -F:::: '{print $10}'`
				PBI_SHORTDESC=`echo $line | awk -F:::: '{print $11}'`
				PBI_APPARCH=`uname -m`
				pbi_display_info
			else
				echo "${PBI_PROGNAME}-${PBI_PROGVERSION}"
			fi

		done
	else
		grep -q -i "::::${PBI_INFONAME}::::" $PBI_INDEXDB
		if [ $? -ne 0 ] ; then 
			exit_err "No such PBI: $PBI_INFONAME"
		fi

		load_pbi_info_index "$PBI_INFONAME"
		pbi_display_info
	fi
}

# Read through the master index file and provide listing of available PBIs for installation
do_index_listing()
{
	# No Database? Ain't gona find much..
	if [ ! -e "$PBI_INDEXDB" ] ; then return; fi

	init_tmpdir

	echo "All available PBIs"
	echo "----------------------------------------------------------------"

	# Build list of all packages / origins
	${PKG_CMD} ${PKG_FLAG} rquery '%o:%n-%v' >${PBI_TMPDIR}/.pList

	while read line
	do
		echo $line | grep -q "^PBI="
		if [ $? -ne 0 ] ; then continue ; fi

		PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
		PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
		PBI_ORIGIN=`echo $line | awk -F:::: '{print $1}' | sed 's|PBI=||g'`
		dName=`grep "^${PBI_ORIGIN}:" ${PBI_TMPDIR}/.pList | cut -d ':' -f 2`
		if [ -n "$dName" ] ; then
			echo $dName
		fi
	done < $PBI_INDEXDB
	exit_trap
}

# Function to pad a variable to X spaces
pad_var() {
	local _pVar="$1"
	local _pNum="$2"
	PAD_VAR="`echo \"$_pVar                                                                                    x\" | cut -c 1-$_pNum`"
}

# Get the full package-name for a target port
get_pkgname() {
        name="`${PKG_CMD} ${PKG_FLAG} info -O ${1} | awk '{print $1}'`"
	PKGNAME="${name}"
}

# Check if we need to pull down the updated INDEX file
check_update_index() {

	init_tmpdir
	local _pbiIndexTime="${PBI_DBINDEXDIR}.time"
		
	# Check if its been greater than $PBI_INDEXREFRESH hours since the last update
	if [ -e "${_pbiIndexTime}" ] ; then
		_curTime=`date +%s`
		_oTime=`cat ${_pbiIndexTime}`
		_trigTime=`expr ${PBI_INDEXREFRESH} \* 60 \* 60`
		expr $_curTime - $_oTime >/dev/null 2>/dev/null
		if [ "$?" = "0" ] ; then
			_passed=`expr $_curTime - $_oTime`
			if [ "$_passed" -lt "$_trigTime" ] ; then
				return 0;
			fi
		fi
		
	fi
	
	cd $PBI_TMPDIR

	# Start refreshing indexes
	if [ "${PBI_VERBOSE}" = "YES" ] ; then
		echo "Updating PBI indexes"
		echo "Updating PBI indexes: `date`" >> ${_pbid_log}
	fi
	
	# Check the specified repo in repo/pkgng-repo file
	foundIndex=0
	local _pRepo="`cat ${PBI_SHARE_DIR}/pkgng-repo`"
	rm ${PBI_INDEXFILE} 2>/dev/null
	rm ${PBI_INDEXFILE}.sha1 2>/dev/null

	# Get the URL for this repo
	url=`cat ${_pRepo} | grep 'url:' | sed 's|url:||g' | awk '{print $1}' | sed 's|^"||g' | sed 's|",$||g'`

	# Fetch the index files if they exist
	fetch -o "${PBI_INDEXFILE}" "${url}/${PBI_INDEXFILE}" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then return 1; fi
	fetch -o "${PBI_INDEXFILE}.sha1" "${url}/${PBI_INDEXFILE}.sha1" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then return 1; fi

	# Got an index file, lets check signatures
	check_file_sig "${PBI_INDEXFILE}"
	if [ $? -ne 0 ] ; then 
		if [ "${PBI_VERBOSE}" = "YES" ] ; then
			echo "Failed verifying signature on PBI Index"
		fi
		echo "Failed verifying signature on PBI Index: `date`" >> ${_pbid_log}
		continue
	fi
	echo "Updating PBI index: `date`" >> ${_pbid_log}

	# Extract the INDEXFILE contents now
	if [ -d "${PBI_DBINDEXDIR}.new" ] ; then
		rm -rf ${PBI_DBINDEXDIR}.new
	fi
	mkdir ${PBI_DBINDEXDIR}.new
	tar xvf ${PBI_INDEXFILE} --no-same-owner -C "${PBI_DBINDEXDIR}.new" >/dev/null 2>/dev/null
	if [ $? -ne 0 ] ; then
		return 1
	fi

	# Move the new index into place
	if [ -e "${PBI_DBINDEXDIR}" ] ; then
	   mv ${PBI_DBINDEXDIR} ${PBI_DBINDEXDIR}.old
	   rm -rf ${PBI_DBINDEXDIR}.old &
	fi
	mv ${PBI_DBINDEXDIR}.new ${PBI_DBINDEXDIR}
		
	# Cleanup
	foundIndex=1
	rm ${PBI_INDEXFILE}
	rm ${PBI_INDEXFILE}.sha1
	
	echo "Finished updating index: `date`" >> ${_pbid_log}
	if [ "${PBI_VERBOSE}" = "YES" ] ; then
		echo "Finished updating index"
	fi

	if [ $foundIndex -eq 0 ] ; then return 1; fi

	# Save the time that we are done
	date +%s > ${_pbiIndexTime}

	return 0
}

is_num()
{
	expr $1 + 1 2>/dev/null
	return $?
}

# Loads some optional meta-data from the package
load_pkg_metadata()
{
  	# Remove any trailing '/'
  	echo $PBI_ORIGIN | grep -q "/$"
  	if [ $? -eq 0 ] ; then
     		PBI_ORIGIN="`echo $PBI_ORIGIN | sed 's|/$||g'`"
  	fi
  	echo $PBI_ORIGIN | grep -q "^/"
  	if [ $? -eq 0 ] ; then
		PBI_ORIGIN="`echo $PBI_ORIGIN | sed 's|^/||g'`"
	fi

	if [ -z "$PBI_LICENSE" ] ; then
		PBI_LICENSE="`${PKG_CMD} rquery '%L' ${PBI_ORIGIN} | head -n 1`"
	fi
	if [ -z "$PBI_SHORTDESC" ] ; then
		PBI_SHORTDESC="`${PKG_CMD} rquery '%c' ${PBI_ORIGIN} | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
	fi
	if [ -z "$PBI_MAINTAINER" ] ; then
		PBI_MAINTAINER="`${PKG_CMD} rquery '%m' ${PBI_ORIGIN}`"
	fi
	if [ -z "$PBI_DESC" ] ; then
		PBI_DESC="`${PKG_CMD} rquery '%e' ${PBI_ORIGIN} | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
	fi
	if [ -z "$PBI_PROGWEB" ] ; then
		PBI_PROGWEB="`${PKG_CMD} rquery '%w' ${PBI_ORIGIN}`"
	fi
	if [ -z "$PBI_CATEGORY" ] ; then
		PBI_CATEGORY="`${PKG_CMD} rquery '%C' ${PBI_ORIGIN} | head -n 1`"
	fi
	if [ -z "$PBI_PROGTYPE" ] ; then
		PBI_PROGTYPE="Text"
	fi
}

# Cleanup after caught exit
exit_trap() {
	# If a download is running, kill it
	if [ -n  "${FETCH_PID}" ] ; then 
	   echo "Killing ${FETCH_PID}"
	   kill -s INT ${FETCH_PID}
           sleep 2
	fi

	rm_tmpdir
	exit 0
}

# Read in the global pbi.conf
load_pbi_etcconf() {

	# FTP_PASSIVE_MODE needs to be enabled by default
	FTP_PASSIVE_MODE=YES
	export FTP_PASSIVE_MODE

	PBI_PUBKEYS="`ls ${PBI_DBKEYDIR}/*.ssl 2>/dev/null`"

	[ -e "${PBI_ETCCONF}" ] || return 0

	# See if we have a custom index refresh rate
	_ckPBIIR="`sed -n 's/^PBI_INDEXREFRESH: //gp' ${PBI_ETCCONF}`"
	if [ -n "${_ckPBIIR}" -a $(is_num "$_ckPBIIR") ] ; then 
		PBI_INDEXREFRESH="${_ckPBIIR}"
	fi

	# See if we have a custom pbid refresh time
	_ckPBID="`cat ${PBI_ETCCONF} | grep '^PBID_REFRESH: ' | sed 's|PBID_REFRESH: ||g'`"
	if [ -n "${_ckPBID}" -a $(is_num "$_ckPBID") ] ; then 
		PBIDSLEEP="${_ckPBID}"
	fi

}

do_ng_migration()
{
	local db="/var/db/pbi/installed"

	require_root
	for i in `ls $db`
	do
		# Get the PBI name
		oName=`cat $db/${i}/pbi_name 2>/dev/null`
		oPath=`cat $db/${i}/pbi_defaultpath 2>/dev/null`
		if [ -n "$oPath" -a -n "$oName" ] ; then
			echo "Removing old PBI: $oName"
			echo "$oPath" | grep -q '/usr/pbi/'
			if [ $? -eq 0 ] ; then
				rm -rf $oPath
			fi
			rm -rf $db/$i

			echo "Adding PBING: $oName"
			pbi add $oName
		fi
	done

}

app_init()
{
  cmd=$1

  # Alias install -> add
  if [ "$cmd" = "install" ] ; then cmd="add" ; fi

  if [ "$cmd" = "help" ] ; then
	case $2 in
	 add|install) usage_add_pbi ;;
	      delete) usage_delete_pbi ;;
		icon) usage_icon_pbi ;;
		info) usage_info_pbi ;;
		*) exit_err "Unknown command" ;;
	esac
  fi

  # User requested to run a migration from old PBIs to PBING
  if [ "$cmd" = "migrate" ] ; then
     do_ng_migration
     exit 0
  fi

  which -s "pbi_${cmd}" 
  if [ $? -ne 0 ] ; then usage_app; fi

  shift
  pbi_${cmd} $*
  exit $?
}

usage_app()
{
   cat <<EOF
usage: `basename $0` <subcommand>

Available sub-commands:

  add
  delete
  help
  icon
  info
  install

EOF
   exit 1
}

# Source our shared PCBSD functions
. /usr/local/share/pcbsd/scripts/functions.sh

# Set the default umask
umask 022

# Main program operation
##############################################################
init_vars
mk_required_dirs

trap exit_trap 1 2 3 9 15

# Figure out which mode we are running in
case `basename ${0}` in
   pbi_add) pbi_add_init "$@" ;;
   pbi_delete) pbi_delete_init "$@" ;;
   pbi_icon) pbi_icon_init "$@" ;;
   pbi_info) pbi_info_init "$@" ;;
   pbi_makeindex) pbi_makeindex_init "$@" ;;
   app) app_init "$@" ;;
   pbi) app_init "$@" ;;
   pbid) pbid_init "$@" ;;
   *) echo "Error: Called with invalid basename!" ; exit_trap ;;
esac

rm_tmpdir
exit 0
