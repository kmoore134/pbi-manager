#!/bin/sh
#
# Copyright 2014 iXsystems (Kris Moore)
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

usage_add_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -e             -- Extract Only
  -f             -- Force install, overwriting existing installation
  -g             -- Get and show path to icon / images for gui installer
  -i             -- Display information about this PBI
  -l             -- Display LICENSE text
  -o outdir      -- Extract to target directory 
  -r 	         -- Fetch and install PBI
  -R 	         -- Fetch install file and save to disk (Do not install)
  -v             -- Enable verbose output
  --container    -- Install packages into stand-alone PBI container
  --checkscript  -- Display any custom install / removal scripts
  --licagree     -- Agree to LICENSE terms for installation
  --meta         -- Display any custom meta-file supplied with the PBI
  --no-checksum  -- Skip the checksum verification during installation
  --no-checksig  -- Ignore signature verification and force install
  --rArch arch   -- Used with -r to specify the specific PBI machine type
  --rVer ver     -- Used with -r to specify the specific PBI version

EOF
        exit_trap
}

usage_autob_pbi() {
        cat <<EOF
usage: `basename $0` [options]

Options:
  -c confdir   -- Directory to traverse looking for meta-data modules <required>
  -d portdir   -- Use different ports dir (Default: /usr/ports)
  -h script    -- Call the following helper script after each build
  -o outdir    -- Where to place the finished PBI file(s) <required>
  -p <num>     -- Number of PBI builds to run concurrently (Defaults to 1)
  -32          -- Build i386 PBIs on amd64 host
  -32fallback  -- On amd64 host, build 32bit PBIs if only i386 can be built
  --keep <num> -- Keep <num> old versions in archive folder for each built PBI
  --prune      -- Remove files from 'outdir' that no longer have a module
  --pkgbuild   -- Build the PBIs using packages from PKGNG
  --tmpfs      -- Use TMPFS for port WRKDIRPREFIX
  --sign key   -- Sign the PBI(s) with specified openssl key

EOF
        exit_trap
}

usage_create_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbidir

Options:
  -a author    -- Application Author
  -b 	       -- Make a backup of an already installed PBI
  -c confdir   -- PBI configuration meta-data directory
  -d portdir   -- Use different ports dir (Default: /usr/ports)
  -i icon      -- Application Icon, relative to pbidir/
  -n name      -- Application Name
  -o outdir    -- Output directory for finished .pbi file
  -p port      -- Pull name / version from FreeBSD Port
  -r version   -- Application Version
  -w url       -- Application Website
  --meta file  -- Include the specified <file> inside the PBI header
		  for display with "pbi_add --meta"
  --sign key   -- Sign the PBI with specified openssl key

EOF
        exit_trap
}

usage_delete_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -v             -- Enable verbose output

EOF
        exit_trap
}

usage_makeindex() {
        cat <<EOF
usage: `basename $0` [openssl key]

To build a PBI index file run 'makeindex' inside a modules directory,
along with the path to your openssl private key for signing. 

EOF

	exit_trap

}


usage_make_pbi() {
        cat <<EOF
usage: `basename $0` [options] port

Options:
  -B 	       -- Build-only, do not run pbi_create when finished
  -c confdir   -- PBI configuration meta-data directory
  -d portdir   -- Use different ports dir (Default: /usr/ports)
  -k           -- Keep build files, don't delete when finished
  -o outdir    -- Where to place the finished PBI file
  -p prefix    -- Specify alternate PBI Compile PREFIX
  -32          -- Build i386 PBI on amd64 host
  --delbuild   -- Delete existing build dirs if they exist
  --meta file  -- Include the specified meta file in the PBI header
  --mkdebug    -- Drop to debug shell if port make fails
  --pkgbuild   -- Build PBI from PKGNG package repo
  --tmpfs      -- Use TMPFS for port WRKDIRPREFIX
  --no-prune   -- Do not prune non REQUIREDBY ports
  --sign key   -- Sign the PBI with specified openssl key

EOF
        exit_trap
}

usage_icon_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  add-desktop          -- Add desktop icons
  add-menu             -- Add menu icons
  add-mime             -- Add mime registration
  add-pathlnk          -- Add PATH links
  del-desktop          -- Remove desktop icons
  del-menu             -- Remove menu icons
  del-mime             -- Remove mime registration
  del-pathlnk          -- Remove PATH links

EOF
        exit_trap
}

usage_info_pbi() {
        cat <<EOF
usage: `basename $0` [options] pbi

Options:
  -a             -- Show all installed PBIs
  -v             -- Enable verbose output

EOF
        exit_trap
}

usage_browse_pbi() {
        cat <<EOF
usage: `basename $0` [options] [repoid]
                
Options:
  -c category  	-- List PBIs from the specified category
  -s search 	-- Search for the specified string
  --listcats  	-- List the available categories in this repository

EOF
        exit_trap
}

# Parse the command line for info
parse_delete_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -v)     PBI_VERBOSE="YES" 
                        ;;
                 *)     if [ $# -gt 1 ]; then usage_delete_pbi; fi
			if [ ! -e "${PBI_DBAPPDIR}/${1}" ] ; then
				find_pbi_namematch "$1"
				if [ -z "$PBI_NAMEMATCH" ] ; then
                                	exit_err "can't find installed pbi (${1})"
				fi
                        	PBI_DELETENAME="$PBI_NAMEMATCH"
			else
                        	PBI_DELETENAME="$1"
                        fi
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_DELETENAME}" ];then usage_delete_pbi; fi
}

find_pbi_namematch()
{
	_fLow="`echo ${1} | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
	PBI_NAMEMATCH=""
	for i in `ls -d ${PBI_DBAPPDIR}/* 2>/dev/null`
	do
		if [ ! -e "$i/pbi_name" ] ; then continue ; fi
		_tLow="`cat $i/pbi_name | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
		if [ "$_tLow" = "$_fLow" ] ; then 
			PBI_NAMEMATCH="`basename ${i}`"
			break
		fi
	done
}

# Parse the command line for icon
parse_icon_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                add-desktop)	PBI_DESKADD="YES" ;;
                add-menu)	PBI_MENUADD="YES" ;;
                add-mime)	PBI_MIMEADD="YES" ;;
                add-pathlnk)	PBI_PATHADD="YES" ;;
                del-desktop)	PBI_DESKDEL="YES" ;;
                del-menu)	PBI_MENUDEL="YES" ;;
                del-mime)	PBI_MIMEDEL="YES" ;;
                del-pathlnk)	PBI_PATHDEL="YES" ;;
                 *)
                        if [ $# -gt 1 ]; then usage_icon_pbi; fi

			# Load this PBI from INDEX
			load_pbi_info_index "$1"
			if [ $? -ne 0 ] ; then
				exit_err "No such PBI: $1"
			fi

			# Check if this PBI is installed
			is_pbi_installed "$PBI_ORIGIN"
			if [ $? -ne 0 ] ; then
				exit_err "PBI not installed: $1"
			fi
			
                       	PBI_ICONTARGETAPP="$1"
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_ICONTARGETAPP}" ] ; then 
		usage_icon_pbi
	fi
}

# Parse the command line for pbid
parse_pbid_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -v)     PBI_VERBOSE="YES" 
                        ;;
         --refresh)     # Schedule us to refresh the index
			echo "Your index files will begin refreshing in a moment..."
			echo "Details available in /var/log/pbid.log"
			rm ${PBI_DBINDEXDIR}/*.time >/dev/null 2>/dev/null
			if [ -e "${PROGBASE}/etc/rc.d/pbid" ]; then
			   ${PROGBASE}/etc/rc.d/pbid restart >/dev/null 2>/dev/null
			fi
			exit 0
                        ;;
		esac
		shift
	done
}

# Parse the command line for info
parse_info_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -a)     PBI_INFONAME="--ALL--"
                        ;;
		-i) 	PBI_INFOINDEX="YES"	
			;;
                -v)     PBI_VERBOSE="YES" 
                        ;;
                 *)
                        if [ $# -gt 1 ]; then usage_info_pbi; fi
			if [ ! -e "${PBI_DBAPPDIR}/${1}" ] ; then
				find_pbi_namematch "$1"
				if [ -z "$PBI_NAMEMATCH" ] ; then
                                	exit_err "can't find installed pbi (${1})"
				fi
                        	PBI_INFONAME="$PBI_NAMEMATCH"
			else
                        	PBI_INFONAME="$1"
                        fi
                        ;;
                esac
                shift
        done
	if [ -z "${PBI_INFONAME}" ] ; then 
		PBI_INFONAME="--ALL--" 
	fi
}

# Parse the command line for browsing
parse_browse_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
        --listcats)     PBI_BROWSE_LISTCATS="YES" ;; 
         --viewall)     PBI_BROWSE_LISTALLPBI="YES" ;; 
                -c)	if [ $# -eq 1  ]; then usage_browse_pbi; fi
                       	shift; PBI_BROWSE_CAT="$1"
			;;
                -s)	if [ $# -eq 1  ]; then usage_browse_pbi; fi
                       	shift; PBI_BROWSE_SEARCH="$1"
			;;
                 *)	if [ $# -gt 1  ]; then usage_browse_pbi; fi
                       	PBI_BROWSE_RID="$1"
                        ;;
                esac
                shift
        done

	if [ -z "${PBI_BROWSE_METAFILE}" ] ; then
		exit_err "The specified repo has no meta-file."
	fi

}

# Parse the command line for adding
parse_add_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -e)     PBI_EXTRACTONLY="YES"
                        ;;
                -f)     PBI_FORCEADD="YES"
                        ;;
                -g)     PBI_ADD_GUIDISPLAY="YES" 
                        ;;
                -i)     PBI_ADD_INFODISPLAY="YES" 
                        ;;
            --meta)     PBI_ADD_METADISPLAY="YES" 
                        ;;
                -l)     PBI_ADD_LICDISPLAY="YES" 
                        ;;
                -o)     if [ $# -eq 1 ]; then usage_add_pbi; fi
                        shift; PBI_ALTEXTRACT_DIR="$1"
                        ;;
                -r)     PBI_REMOTEFETCH="YES" 
			;;
                -R)     PBI_REMOTEFETCH="YES" 
			PBI_REMOTEFETCHONLY="YES"
			;;
                -v)     PBI_VERBOSE="YES" 
                        ;;
           --rArch)     
                        if [ $# -eq 1 ]; then usage_add_pbi; fi
                        shift; PBI_ADD_ALTARCH="$1"
                        ;;
           --rVer)     
                        if [ $# -eq 1 ]; then usage_add_pbi; fi
                        shift; PBI_ADD_ALTVER="$1"
                        ;;
       --container)     PBI_DOCONTAINER="YES" ;;
     --checkscript)     PBI_CHECKSCRIPTS="YES" ;;
        --licagree)     PBI_LICAGREE="YES" ;;
     --no-checksum)     PBI_SKIPCHECKSUM="YES" ;;
     --no-checksig)     PBI_SKIPSIGVERIFY="YES" ;;
                 *)
                        if [ $# -gt 1 ]; then usage_add_pbi; fi
			# If there is no file we are doing pkg install
                        if [ -e "${1}" ] ; then
				PBI_DOCONTAINER="YES"
			fi
                        PBI_FILENAME="$1"
                        ;;
                esac
                shift
        done

        if [ -z "${PBI_FILENAME}" ]; then usage_add_pbi ; fi

	# If this isn't a stand-alone container version we can stop here
	if [ "$PBI_DOCONTAINER" != "YES" ] ; then return; fi

        # Load all the information about this PBI
        load_info_from_header

        if [ -z "${PBI_ORIGPROGDIRPATH}" ]; then usage_add_pbi ; fi

        # Lastly set PBI_PROGDIRNAME
        PBI_PROGDIRNAME="`echo ${PBI_ORIGPROGDIRPATH} | rev | cut -d '/' -f 1 | rev`"


	if [ "${PBI_EXTRACTONLY}" = "YES" ] ; then
		# If extracting to a alt-outdir, set it now
		PBI_PROGDIRPATH="`pwd`/${PBI_PROGDIRNAME}"

		if [ -n "${PBI_ALTEXTRACT_DIR}" ]; then
			PBI_PROGDIRPATH="${PBI_ALTEXTRACT_DIR}/${PBI_PROGDIRNAME}"
		fi
	else
		# Set the installation dir
		PBI_PROGDIRPATH="${PBI_ORIGPROGDIRPATH}"
	fi
}

# Parse the command line
parse_autob_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -c)     if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        if [ -n "${PBI_AB_CONFDIR}" ]; then usage_autob_pbi; fi
                        shift
                        get_abspath "$1"
                        PBI_AB_CONFDIR="$_ABSPATH"
                        if [ ! -d "${PBI_AB_CONFDIR}" ] ; then
                                exit_err "Invalid confdir (${PBI_AB_CONFDIR})"
                        fi
                        ;;
                -d)	if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift
                        get_abspath "$1"
                        PORTSDIR="$_ABSPATH"
                        ;;
                -o)	if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift
                        get_abspath "$1"
                        PBI_AB_OUTDIR="$_ABSPATH"
                        ;;
                -p)	if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift
                        PBI_AB_BUILDERS="$1"
			if [ ! $(is_num "$PBI_AB_BUILDERS") ] ; then 
				exit_err "Invalid process number specifed!"
			fi
                        ;;
                -h)	if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift
                        get_abspath "$1"
                        PBI_AB_HELPS="$_ABSPATH"
                        ;;
                -32)    if [ "$REALARCH" != "amd64" ] ; then 
				exit_err "-32 can only be used on amd64 host"
			fi	
			PBI_AB32="YES"
			ARCH=i386
                        ;;
        -32fallback)    if [ "$REALARCH" != "amd64" ] ; then 
				exit_err "-32fallback can only be used on amd64 host"
			fi	
			PBI_ABFB32="YES"
                        ;;

        --pkgbuild)     PBI_AB_PKGBUILD="YES" 
                        ;;
            --keep)     if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift; PBI_AB_ARCHIVENUM="$1"
			expr $PBI_AB_ARCHIVENUM + 1 >/dev/null 2>/dev/null
			if [ $? != 0 ] ; then usage_autob_pbi; fi
                        ;;
           --prune)     PBI_AB_PRUNE="YES" 
                        ;;
           --tmpfs)     PBI_AB_TMPFS="YES" 
                        ;;
            --sign)     if [ $# -eq 1 ]; then usage_autob_pbi; fi
                        shift; PBI_AB_SSLPRIVKEY="$1"
                        ;;
                 *)     usage_autob_pbi ;;
                esac
                shift
        done

	if [ -z "$PBI_AB_OUTDIR" ] ; then usage_autob_pbi ; fi
	if [ -z "$PBI_AB_CONFDIR" ] ; then usage_autob_pbi ; fi
}


# Parse the command line
parse_create_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -a)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CAUTHOR="$1"
                        ;;
                -b)     PBI_CBACKUP="YES"
                        ;;
                -c)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; 
			get_abspath "$1"
			PBI_CONFDIR="$_ABSPATH"
			if [ ! -d "${PBI_CONFDIR}" ] ; then
				exit_err "Invalid confdir (${PBI_CONFDIR})"
			fi
			load_pbi_conffile
                        ;;
                -d)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PORTSDIR="$1"
                        ;;
               --meta)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CREATE_USERMETA="$1"
			if [ ! -e "$PBI_CREATE_USERMETA" ] ; then
				exit_err "No such file: $PBI_CREATE_USERMETA"
			fi
                        ;;
                -i)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CICON="$1"
                        ;;
                -n)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CNAME="$1"
                        ;;
                -o)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CREATE_OUTDIR="$1"
                        ;;
                -p)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_MAKEPORT="$1"
                        ;;
                -r)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CVERSION="$1"
                        ;;
                -w)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_CWEB="$1"
                        ;;
            --sign)	if [ $# -eq 1 ]; then usage_create_pbi; fi
                        shift; PBI_SSLPRIVKEY="$1"
                        ;;
                 *)
                        if [ $# -gt 1 ]; then usage_create_pbi; fi
			if [ "$PBI_CBACKUP" = "YES" ] ; then
				if [ ! -e "${PBI_DBAPPDIR}/${1}" ] ; then
					find_pbi_namematch "$1"
					if [ -z "$PBI_NAMEMATCH" ] ; then
                                		exit_err "can't find installed pbi (${1})"
					fi
					PBI_CBACKUPTARGET="${PBI_NAMEMATCH}"
					PBI_PROGDIRPATH="${PBI_NAMEMATCH}"
				else
					PBI_CBACKUPTARGET="${1}"
					PBI_PROGDIRPATH="${1}"
                        	fi
			else
				get_abspath "$1"
				PBI_PROGDIRPATH="$_ABSPATH"
                        	if [ ! -d "${PBI_PROGDIRPATH}" ] ; then
                                	exit_err "Invalid pbidir (${1})"
                          	fi
			fi
                        ;;
                esac
                shift
        done

	# Make sure this port exists
        if [ -n "${PBI_MAKEPORT}" -a ! -d "${PORTSDIR}/${PBI_MAKEPORT}" ]; then
		exit_err "No port (${PORTSDIR}/${PBI_MAKEPORT})"
	fi

	# Load the name / version from specified port
        if [ -n "${PBI_MAKEPORT}" ]; then
		get_pbi_progversion
		get_pbi_progname
        fi

        if [ -z "${PBI_PROGDIRPATH}" ]; then usage_create_pbi ; fi

	# Remove any trailing '/' from PBI_MAKEPORT
	echo $PBI_MAKEPORT | grep -q "/$"
	if [ $? -eq 0 ] ; then
		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
	fi

	# Lastly set PBI_PROGDIRNAME
	PBI_PROGDIRNAME="`echo ${PBI_PROGDIRPATH} | rev | cut -d '/' -f 1 | rev`"
}

# Override any pbi.conf values with passed command-line values
parse_cmdline_overrides() {
	if [ -n "${PBI_CNAME}" ] ; then PBI_PROGNAME="${PBI_CNAME}" ; fi
	if [ -n "${PBI_CVERSION}" ] ; then PBI_PROGVERSION="${PBI_CVERSION}" ; fi
	if [ -n "${PBI_CWEB}" ] ; then PBI_PROGWEB="${PBI_CWEB}" ; fi
	if [ -n "${PBI_CAUTHOR}" ] ; then PBI_PROGAUTHOR="${PBI_CAUTHOR}" ; fi
	if [ -n "${PBI_CICON}" ] ; then PBI_PROGICON="${PBI_CICON}" ; fi
}

# Parse the command line
parse_make_pbi_cmdline() {
        while [ $# -gt 0 ]; do
                case "$1" in
                -B)	PBI_BUILDONLY="YES"
                        ;;
                -c)
                        if [ $# -eq 1 ]; then usage_make_pbi; fi
                        if [ -n "${PBI_CONFDIR}" ]; then usage_make_pbi; fi
                        shift
			get_abspath "$1"
			PBI_CONFDIR="$_ABSPATH"
                        ;;
                -d)
                        if [ $# -eq 1 ]; then usage_make_pbi; fi
                        shift; PORTSDIR="$1" ; export PORTSDIR
                        ;;

                -32)    if [ "$REALARCH" != "amd64" -a "`basename $0`" != "pbi_makeport_chroot" ] ; then 
				exit_err "-32 can only be used on amd64 host"
			fi	
			ARCH=i386
                        ;;

                -k)	PBI_KEEPBUILDFILES="YES"
                        ;;

                --delbuild)	MKDELBUILD="YES"
                        ;;
                --no-prune)	PBI_PRUNEBUILDPORTS="NO"
                        ;;
                --mkdebug)	MKDEBUG="YES"
                        ;;
                --pkgbuild)	PBI_PKGNGBUILD="YES"
                        ;;
                --tmpfs)	MKTMPFS="YES"
                        ;;
               --meta)	if [ $# -eq 1 ]; then usage_make_pbi; fi
                        shift; PBI_CREATE_USERMETA="$1"

			# If running the chroot portion, reset the location
			if [ "`basename $0`" = "pbi_makeport_chroot" ] ; then
				PBI_CREATE_USERMETA="/user-meta"
			fi

			# Check to ensure it exists
			if [ ! -e "$PBI_CREATE_USERMETA" ] ; then
				exit_err "No such file: $PBI_CREATE_USERMETA"
			fi
                        ;;
                -o)	if [ $# -eq 1 ]; then usage_make_pbi; fi
                        shift
			get_abspath "$1"
			PBI_CREATE_OUTDIR="$_ABSPATH"
                        ;;
                -p)	if [ $# -eq 1 ]; then usage_make_pbi; fi
                        if [ -n "${PBI_MAKEPREFIX}" ]; then usage_make_pbi; fi
                        shift; PBI_MAKEPREFIX="$1"
                        ;;
            --sign)	if [ $# -eq 1 ]; then usage_make_pbi; fi
			shift
			get_abspath "$1"
			PBI_SSLPRIVKEY="$_ABSPATH"
                        ;;
                 *)
                        if [ $# -gt 1 ]; then usage_make_pbi; fi
                        PBI_MAKEPORT="$1"
                        ;;
                esac
                shift
        done

	# Override some locations if working in chroot environment
	if [ "`basename $0`" = "pbi_makeport_chroot" ] ; then 
		if [ -n "${PBI_CONFDIR}" ] ; then PBI_CONFDIR="/pbimodule" ; fi
		if [ -n "${PBI_SSLPRIVKEY}" ] ; then PBI_SSLPRIVKEY="/privkey.pem" ; fi
		if [ -n "${PBI_CREATE_OUTDIR}" ] ; then PBI_CREATE_OUTDIR="/pbiout" ; fi
		if [ -n "${PORTSDIR}" ] ; then PORTSDIR="/usr/ports" ; fi
	fi


	# Make sure this port exists
	if [ ! -d "${PORTSDIR}/${PBI_MAKEPORT}" -a "$PBI_PKGNGBUILD" != "YES" ] ; then
		exit_err "No port (${PORTSDIR}/${PBI_MAKEPORT})"
	fi

	# Remove any trailing '/' from PBI_MAKEPORT
	echo $PBI_MAKEPORT | grep -q "/$"
	if [ $? -eq 0 ] ; then
		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
	fi

	# Make sure we have a valid PBI_CONFDIR
	if [ -n "${PBI_CONFDIR}" -a ! -d "${PBI_CONFDIR}" ] ; then
		exit_err "Invalid confdir (${PBI_CONFDIR})"
	fi

	# Source the config file
	if [ -n "${PBI_CONFDIR}" ]; then load_pbi_conffile ; fi

        if [ -z "${PBI_MAKEPORT}" ]; then
                usage_make_pbi
        fi
}

# Make some of our required PBI dirs
mk_required_dirs() {
	if [ ! -d "${PBI_APPDIR}" ] ; then mkdir -p ${PBI_APPDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_XDGCFGDIR}" ] ; then mkdir -p ${PBI_XDGCFGDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_XDGAPPDIR}" ] ; then mkdir -p ${PBI_XDGAPPDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_XDGDIRDIR}" ] ; then mkdir -p ${PBI_XDGDIRDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_XDGICONDIR}" ] ; then mkdir -p ${PBI_XDGICONDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_XDGMIMEDIR}" ] ; then mkdir -p ${PBI_XDGMIMEDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_RCDIR}" ] ; then mkdir -p ${PBI_RCDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_BINDIR}" ] ; then mkdir -p ${PBI_BINDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_MANDIR}" ] ; then mkdir -p ${PBI_MANDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_DBAPPDIR}" ] ; then mkdir -p ${PBI_DBAPPDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_DBKEYDIR}" ] ; then mkdir -p ${PBI_DBKEYDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_DBMIRRORDIR}" ] ; then mkdir -p ${PBI_DBMIRRORDIR} >/dev/null 2>/dev/null ; fi
	if [ ! -d "${PBI_DBINDEXDIR}" ] ; then mkdir -p ${PBI_DBINDEXDIR} >/dev/null 2>/dev/null ; fi

	# Set the permissions for directories if we are running as root
	if [ `id -u` != "0" ] ; then return ; fi

	for cDir in $PBI_APPDIR $PBI_DBAPPDIR $PBI_XDGCFGDIR $PBI_XDGAPPDIR $PBI_XDGDIRDIR $PBI_XDGICONDIR $PBI_XDGMIMEDIR
	do	
		chown root:${PBI_INSTALLGROUP} ${cDir}
		chmod 775 ${cDir}
	done

}

# Get the absolute path of a dir, even a realative dir. 'realpath' doesn't work here
get_abspath() {
	D=`dirname "$1"`
	B=`basename "$1"`
	if [ "$D" = "/" ] ; then
		_ABSPATH="/$B"
	else
		_ABSPATH="`cd \"$D\" 2>/dev/null && pwd || echo \"$D\"`/$B"
	fi
}


# Initialize some vars
init_vars() {

	# Set sys vars
	REALARCH="`uname -m`"
	ARCH="$REALARCH"

        # Where is pbi-manager installed?
        PROGBASE=/usr/local
	SYS_LOCALBASE=/usr/local
	PBI_SHARE_DIR="${PROGBASE}/share/pbi-manager"
	if [ -z "${PBI_APPDIR}" -o "`basename $0`" = "pbi_makeport_chroot" ] ; then
		PBI_APPDIR="/usr/pbi"
        fi
	# Set the FreeBSD Major & Release
  	FBSDREL=`uname -r | cut -d "-" -f 1-2`
	FBSDMAJOR=`echo $FBSDREL | cut -d "-" -f 1 | cut -d '.' -f 1`

	PBI_WORLDCHROOT="${PBI_APPDIR}/.pbi-world-$ARCH"
	PBI_AB_BUILDERS=1
	PBI_XDGCFGDIR="${PBI_APPDIR}/etc/xdg/menus"
	PBI_XDGAPPDIR="${PBI_APPDIR}/share/applications"
	PBI_XDGDIRDIR="${PBI_APPDIR}/share/desktop-directories"
	PBI_XDGICONDIR="${PBI_APPDIR}/share/icons/hicolor"
	PBI_XDGMIMEDIR="${PBI_APPDIR}/share/mime/packages"
	PBI_RCDIR="${PBI_APPDIR}/rc.d"
	PBI_BINDIR="${PBI_APPDIR}/bin"
	PBI_MANDIR="${PBI_APPDIR}/man"
	PBI_ETCCONF="${SYS_LOCALBASE}/etc/pbi.conf"
	PCBSD_ETCCONF="${SYS_LOCALBASE}/etc/pcbsd.conf"
	PBI_DEFAULT_ICON="${PROGBASE}/share/pbi-manager/icons/default.png"
	PBI_DEFAULT_ICON_CHROOT="/default.png"
	PBI_LDCONFIGFILE="${PROGBASE}/etc/ldpbiconfig"
	PBI_LDCONFIGRC="${PROGBASE}/etc/rc.d/ldpbiconfig"

	# Set the PBI DB dir
	if [ -z "${PBI_DBDIR}" ] ; then
		PBI_DBDIR="/var/db/pbi"
	fi
	PBI_DBKEYDIR="${PBI_DBDIR}/keys"
	PROGVERSION="1.0"

	# Load the etc/pbi.conf file
	load_pbi_etcconf

	# Overrides from pbi.conf
	if [ -z "$PBIDSLEEP" ] ; then
		PBIDSLEEP="300"	# Amount of time to sleep before waking up pbid
	fi
	if [ -z "$PBI_INDEXREFRESH" ] ; then
		PBI_INDEXREFRESH="24" # Hours to wait until we re-download PBI indexes
	fi
	if [ -n "$PBI_MAJORVERSION" ] ; then
		FBSDMAJOR=${PBI_FBSDMAJOR}
	fi

	PBI_LOG_LINES="500"
	PBI_INSTALLGROUP="operator"

	# What dbus dirs do we parse for setting up services
	DBUS_SEARCH_DIRS="share/dbus-1 kde4/share/dbus-1 gnome/share/dbus-1"

	# Don't modify unless you know what your doing!
	MOD_PREINS="pre-install.sh"
	MOD_POSTINS="post-install.sh"
	MOD_PREREM="pre-remove.sh"
	MOD_XDGDESK_DIR="xdg-desktop"
	MOD_XDGMENU_DIR="xdg-menu"
	MOD_XDGMIME_DIR="xdg-mime"
	MOD_EXTLINKFILE="external-links"
	MOD_AUTOEXTLINKFILE=".auto-external-links"
	PBI_ADD_GUIDISPLAY="NO"
	PBI_ADD_INFODISPLAY="NO"
	PBI_ADD_METADISPLAY="NO"
	PBI_ADD_LICDISPLAY="NO"
	PBI_APPDESK_DIR=".${MOD_XDGDESK_DIR}"
	PBI_APPMENU_DIR=".${MOD_XDGMENU_DIR}"
	PBI_APPMIME_DIR=".${MOD_XDGMIME_DIR}"
	PBI_BUILD_USERS=""
	PBI_BUILD_GROUPS=""
	PBI_INS_USERSFILE=".pbi-uids"
	PBI_INS_GROUPSFILE=".pbi-gids"
	PBI_DESKADD="NO"
	PBI_MENUADD="NO"
	PBI_MIMEADD="NO"
	PBI_PATHADD="NO"
	PBI_DESKDEL="NO"
	PBI_MAKECONF="/etc/pbi-make.conf"
	PBI_MENUDEL="NO"
	PBI_MIMEDEL="NO"
	PBI_PATHDEL="NO"
	PBI_DELETENAME=""
	PBI_FAKEBIN_DIR="bin"
	PBI_FAKERC_DIR="rc.d"
	PBI_FILENAME=""
	PBI_FORCEADD="NO"
	PBI_INDEXFILE="PBI-INDEX.txz"
	PBI_INFONAME=""
	PBI_INS_DESKSCRIPT="install-desktop-icons.sh"
	PBI_INS_MENUSCRIPT="install-menu-icons.sh"
	PBI_INS_MIMESCRIPT="install-mime.sh"
	PBI_INS_PATHSCRIPT="install-pathlinks.sh"
	PBI_ICDIR="pbi-shared-icons"
	PBI_LICAGREE="NO"
	PBI_LICENSEFILE="LICENSE"
	PBI_USERMETAFILE="metafile"
	PBI_REMOTEFETCH=""
	PBI_REMOTEFETCHONLY=""
	PBI_RESOURCE_DIR="resources"
	PBI_SS_ICON="__PBI_ICON__"
	PBI_SS_ARCHIVE="__PBI_ARCHIVE__"
	PBI_SSLPRIVKEY=""
	PBI_TMPDIR="/tmp/.PBI.$$"
	PBI_UPCHECK=""
	PBI_UNINS_DESKSCRIPT="uninstall-desktop-icons.sh"
	PBI_UNINS_MENUSCRIPT="uninstall-menu-icons.sh"
	PBI_UNINS_MIMESCRIPT="uninstall-mime.sh"
	PBI_UNINS_PATHSCRIPT="uninstall-pathlinks.sh"

        # User overridable variables
	MKDELBUILD=""
	MKDEBUG=""
	MKTMPFS=""
	PBI_AB_ARCHIVENUM=""
	PBI_AB_CONFDIR=""
	PBI_AB_HELPS=""
	PBI_AB_OUTDIR=""
	PBI_AB_SSLPRIVKEY=""
	PBI_AB_PRUNE=""
	PBI_AB_TMPFS=""
	PBI_BUILDONLY="NO"
	PBI_CAUTHOR=""
	PBI_CBACKUP=""
	PBI_CBACKUPTARGET=""
	PBI_CHECKSCRIPTS=""
	PBI_CICON=""
	PBI_CNAME=""
        PBI_CONFDIR=""
	PBI_CONFFILE="pbi.conf"
        PBI_CONF_SCRIPTSDIR="scripts/"
	PBI_CREATE_OUTDIR="$HOME"
	PBI_CWEB=""
	PBI_DBAPPDIR="${PBI_DBDIR}/installed"
	PBI_DBINDEXDIR="${PBI_DBDIR}/index"
	PBI_INDEXDB="${PBI_DBINDEXDIR}/PBI-INDEX"
	PBI_DOCONTAINER=""
	PBI_GUITOPBANNER="gui_banner.png"
	PBI_GUISIDEBANNER="gui_sidebanner.png"
	PBI_KEEPBUILDFILES="NO"
	PBI_MAKEPORT=""
	PBI_MAKEPREFIX=""
	PBI_MAKEOPTS=""
	PBI_MKPORTBEFORE=""
	PBI_MKPORTAFTER=""
	PBI_PORTSDIR=""
	PBI_PROGAUTHOR=""
	PBI_PROGMDATE=""
	PBI_PROGEPOCH=""
	PBI_PROGNAME=""
	PBI_PROGDIRNAME=""
	PBI_PROGDIRPATH=""
	PBI_PROGICON=""
	PBI_PROGREVISION=""
	PBI_PROGVERSION=""
	PBI_PROGWEB=""
	PBI_PRUNEBUILDPORTS="YES"
	PBI_SKIPCHECKSUM=""
	PBI_SKIPSIGVERIFY=""
	PBI_USESYSGL="YES"
	PBI_USESYSFONTS="YES"
	PBI_VERBOSE="NO"
	PORTSDIR="/usr/ports"

}

detect_pkgng()
{
        export PKG_ADD="pkg add"
        export PKG_DELETE="pkg delete -y -f"
}

# Set and export vars used by module scripts
export_script_vars() {
	# Load some initial values
	get_pbi_progdir
	get_pbi_progversion

	export PBI_PROGNAME PBI_PROGDIRNAME PBI_PROGDIRPATH PBI_PROGVERSION PBI_RCDIR PBI_MANDIR PBI_BINDIR
	export SYS_LOCALBASE PBI_FAKEBIN_DIR PBI_FAKERC_DIR
}

# init tmpdir
init_tmpdir() {
	if [ -d "${PBI_TMPDIR}" ] ; then return; fi
	if [ -z "${PBI_TMPDIR}" ] ; then return ; fi
	if [ "${PBI_TMPDIR}" = "/" ] ; then return ; fi
	if [ -e "${PBI_TMPDIR}" ] ; then rm -rf "${PBI_TMPDIR}" ; fi
	mkdir -p "${PBI_TMPDIR}"
}

# rm tmpdir
rm_tmpdir() {
	if [ -z "${PBI_TMPDIR}" -o "${PBI_TMPDIR}" = "/" ] ; then return 0; fi
	if [ -e "${PBI_TMPDIR}" ] ; then rm -rf "${PBI_TMPDIR}" ; fi
}

# rm tmpdir
rm_buildfiles() {
	if [ "${PBI_KEEPBUILDFILES}" = "YES" ] ; then return ; fi
	if [ -z "$PBI_CHROOTDIR" ] ; then return ; fi
	chroot_make_cleanup
}

# Load PBI conf options
load_pbi_conffile() {
  	if [ ! -d "${PBI_CONFDIR}" ] ; then return 0 ; fi
  	if [ -e "${PBI_CONFDIR}/${PBI_CONFFILE}" ] ; then
		unset PBI_MAKEPORT PBI_BUILDKEY PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_PROGREVISION PBI_AB_NOPKGBUILD
		. ${PBI_CONFDIR}/${PBI_CONFFILE}

		# Remove any trailing '/' from PBI_MAKEPORT
		echo $PBI_MAKEPORT | grep -q "/$"
		if [ $? -eq 0 ] ; then
			PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
		fi
	fi
}

# Get the PBI_PROGVERSION
get_pbi_progversion() {

	if [ -n "${PBI_PROGVERSION}" ] ; then return 0 ; fi

	load_pbi_conffile

	# If we have PBI_PROGVERSION now set
	if [ -n "${PBI_PROGVERSION}" ] ; then return 0 ; fi

  	# Remove any trailing '/'
  	echo $PBI_MAKEPORT | grep -q "/$"
  	if [ $? -eq 0 ] ; then
     		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  	fi

	# Check first if we have this pkg in PKGNG
	if [ -n "$PBI_PKGNGBUILD" -a -z "$PBI_AB_NOPKGBUILD" ] ; then
		testPkgVer="`pkg-static rquery '%v' ${PBI_MAKEPORT}`"
		if [ -z "$testPkgVer" ] ; then
			# Try one more time, just in case PKGNG was busy, silly database locking
			sleepRand="`jot -r 1 1 90`"
			sleep $sleepRand
			testPkgVer="`pkg-static rquery '%v' ${PBI_MAKEPORT}`"
		fi
		if [ -n "$testPkgVer" ] ; then
			PBI_PROGVERSION="$testPkgVer"
			# If we have a REVISION, use it as well
			if [ -n "$PBI_PROGREVISION" ] ; then
				PBI_PROGVERSION="${PBI_PROGVERSION}_${PBI_PROGREVISION}"
			fi
			export PBI_PROGVERSION
			return 0
		fi
		exit_err "Failed to get PBI_PROGVERSION for ${PBI_MAKEPORT}"
	fi

	# Get the version from ports
	if [ -z "${PBI_PROGVERSION}" -a -n "${PORTSDIR}" -a -n "${PBI_MAKEPORT}" ] ; then
		PORTVER="`make -C ${PORTSDIR}/${PBI_MAKEPORT} -V DISTVERSION PORTSDIR=${PORTSDIR} 2>/dev/null`"

  		# Check if we have a portrevision to use in version number
  		PORTREV=""
  		PORTREV="`make -C ${PORTSDIR}/${PBI_MAKEPORT} -V PORTREVISION PORTSDIR=${PORTSDIR} 2>/dev/null`"
  		if [ -n "${PORTREV}" -a "${PORTREV}" != "0" ]
 		then
			PBI_PROGVERSION="${PORTVER}_${PORTREV}"
		else
			PBI_PROGVERSION="${PORTVER}"
		fi

		if [ -z "${PBI_PROGVERSION}" ] ; then
			echo "Warning: Unable to set PBI_PROGVERSION with:"
		        echo "make -C ${PORTSDIR}/${PBI_MAKEPORT} -V DISTVERSION PORTSDIR=${PORTSDIR}"
		fi
	else
		echo "PBI_PROGVERSION - $PBI_PROGVERSION - PORTSDIR - ${PORTSDIR} - $PBI_MAKEPORT - $PBI_MAKE_PORT - pbi - $pbi"
		exit_err "Failed to locate PBI_PROGVERSION"
	fi

	# If we have a REVISION, use it as well
	if [ -n "$PBI_PROGREVISION" ] ; then
		PBI_PROGVERSION="${PBI_PROGVERSION}_${PBI_PROGREVISION}"
	fi
}


# Get the PBI_PROGNAME
get_pbi_progname() {
	if [ -z "${PBI_PROGNAME}" -o "${PBI_PROGNAME}" = " " ] ; then
		load_pbi_conffile
	else
		return 0
	fi

	if [ -z "${PBI_PROGNAME}" -a -n "${PORTSDIR}" -a -n "${PBI_MAKEPORT}" ] ; then
		# Get the proper package name from the prefix + name + suffix
		local pkgPrefix="`make -C ${PORTSDIR}/${PBI_MAKEPORT} -V PKGNAMEPREFIX PORTSDIR=${PORTSDIR}`"
		local pkgName="`make -C ${PORTSDIR}/${PBI_MAKEPORT} -V PORTNAME PORTSDIR=${PORTSDIR}`"
		local pkgSuffix="`make -C ${PORTSDIR}/${PBI_MAKEPORT} -V PKGNAMESUFFIX PORTSDIR=${PORTSDIR}`"
		PBI_PROGNAME="${pkgPrefix}${pkgName}${pkgSuffix}"
	else
		exit_err "Failed to locate PBI_PROGNAME"
	fi
}

# Get the PBI PROGDIR Name
get_pbi_progdir() {
	if [ -z "${PBI_PROGNAME}" ] ; then
		get_pbi_progname
	fi

	tmp="`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]' | sed 's|+||g'`"
	if [ -z "${PBI_PROGDIRNAME}" ] ; then
		PBI_PROGDIRNAME="${tmp}-${ARCH}"
	fi
	if [ -z "${PBI_PROGDIRPATH}" ] ; then
		PBI_PROGDIRPATH="${PBI_APPDIR}/${PBI_PROGDIRNAME}"
	fi
}

# Helper function to exit after a error, and do some cleanup
exit_err() {
	echo -e "`basename ${0}`: ${1}"
	rm_tmpdir
	rm_buildfiles
	chroot_make_cleanup
	exit 255
}

# Set port make options from config
set_make_options() {

	local MAKE_CONF="/etc/make.conf"

	echo "PACKAGE_BUILDING=yes" >> ${MAKE_CONF}
	echo "BATCH=yes" >> ${MAKE_CONF}
	echo "NO_IGNORE=yes" >> ${MAKE_CONF}
	echo "WITH_PKGNG=yes" >> ${MAKE_CONF}

	echo "WRKDIRPREFIX=/usr/wrkdirprefix" >> ${MAKE_CONF}
	echo "DEPENDS_CLEAN=YES" >> ${MAKE_CONF}

	if [ -n "$PBI_MAKEOPTS" ] ; then
		# Check if we have custom make opts
		echo "${PBI_MAKEOPTS}" >> ${MAKE_CONF}
	fi

	if [ ! -d "/usr/local" ] ; then
		mkdir -p /usr/local
	fi 

	# Make sure ldconfig is primed
	/etc/rc.d/ldconfig start

	if [ -z "$PBI_PKGNGBUILD" ] ; then
		echo "Building pkgng..."
		cd /usr/ports/ports-mgmt/pkg
		make install clean
		if [ $? -ne 0 ] ; then exit_err "Failed building pkgng!" ; fi 
	fi

	# Check if using ccache directory
	if [ -d "/.ccache" ] ; then
		echo "Enabling ccache..."
		cd /usr/ports/devel/ccache 
		make install clean
		if [ $? -eq 0 ] ; then
			# Setup environment variables
			CCACHE_PATH="/usr/bin:/usr/local/bin"
			export CCACHE_PATH
			CCACHE_DIR="/.ccache"
			export CCACHE_DIR
			PATH="/usr/local/libexec/ccache:${PATH}"
			export PATH

			# Setup make configuration
			echo ".if !defined(NO_CCACHE)" >> ${MAKE_CONF}
			echo "  CC=/usr/local/libexec/ccache/world/cc" >> ${MAKE_CONF}
			echo "  CXX=/usr/local/libexec/ccache/world/c++" >> ${MAKE_CONF}
			echo ".endif" >> ${MAKE_CONF}
		else
			echo "Failed installing ccache! Continuing without it..."
		fi
	fi

	PATH="${PATH}:/usr/local/bin:/usr/local/sbin"
	export PATH

	FORCE_PKG_REGISTER="Y"
	export FORCE_PKG_REGISTER

}

# Confirm we are running as root
require_root() {
  if [ `id -u` != "0" ] ; then
     exit_err "Must be run as root!"
  fi 
}

# Confirm we are running as root or the proper group for installation
require_root_or_group() {
  if [ `id -u` = "0" ] ; then return 0 ; fi 
  touch ${PBI_APPDIR}/.ptest.$$ >/dev/null 2>/dev/null
  if [ "$?" = "0" ] ; then 
	rm ${PBI_APPDIR}/.ptest.$$ >/dev/null 2>/dev/null
	return 0
  fi
  exit_err "Must be run as root or a member of the $PBI_INSTALLGROUP group!"
}

# Function to get the username from a file
get_username_from_file() {
	if [ -f "${1}" ] ; then 
		FILEUSER=`ls -al ${1} | awk '{print $3}'`
		export FILEUSER
		return 0
	fi
	if [ -d "${1}" ] ; then 
		FILEUSER=`ls -al ${1} | grep -v "total" | head -n 1 | awk '{print $3}'`
		export FILEUSER
		return 0
	fi
	exit_err "Invalid file for usercheck!"
}

# Create a PBI repoindex from a modules directory
pbi_makeindex_init() {
	# Make sure we have been given a signing key
	if [ -z "$1" -o ! -e "$1" ] ; then
		usage_makeindex
	fi

	# Create a new repoindex file
	make_pbi_index "$1"
}

# Create a PBI-INDEX file and save it, along with scripts to a .txz file
make_pbi_index() {

   sKey="$1"

   if [ ! -e "PBI-categories" ] ; then
      exit_err "No PBI-categories file.. Is this a modules directory?"
   fi
   if [ -d "PBI-icons" ] ; then
      echo "Removing old PBI-icons.."
      rm -rf PBI-icons
   fi
	
   # Set our delimiter and temp INDEX files
   d="::::"
   tI=".INDEX.$$"
   tIco=".icons.$$"
   touch $tI
   mkdir $tIco

   for pbi in `find . -type f -name "${PBI_CONFFILE}" | grep -v '\.svn' | grep -v '\.git' | sort`
   do
	# Figure out the target port for this build
	unset PBI_MAKEPORT PBI_BUILDKEY PBI_PROGVERSION PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_AB_NOPKGBUILD PBI_SCREENSHOTS PBI_RELATED PBI_PLUGINS PBI_CONTAINER PBI_DESC PBI_SHORTDESC

	. ${pbi}

	_cd=$(dirname $pbi | sed 's|./||')
	PBI_CONFDIR="$_cd"

	# Make sure PBI_MAKEPORT is set
	if [ -z "${PBI_MAKEPORT}" ] ; then
		PBI_MAKEPORT=`echo $pbi | sed 's|./||'`
		export PBI_MAKEPORT
	fi	

  	# Remove any trailing '/'
  	echo $PBI_MAKEPORT | grep -q "/$"
  	if [ $? -eq 0 ] ; then 
		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  	fi
	
	# Check for missing port target
	if [ -z "$PBI_MAKEPORT" ] ; then
		#echo "Warning: Missing PBI_MAKEPORT for ${pbi}"
		continue
	fi

	# Make sure this PBI exists in the repo
	pkg-static rquery '%n' $PBI_MAKEPORT >/dev/null 2>/dev/null
	if [ $? -ne 0 ] ; then 
		echo "Warning: Package missing for $PBI_CONFDIR ($PBI_MAKEPORT)"
		continue
	fi

	# Check that all the required packages are available
	skip=0
	for port in ${PBI_MKPORTBEFORE}
	do
  		# Cleanup $port
  		echo $port | grep -q "/$"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|/$||g'`"; fi
  		echo $port | grep -q "^/"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|^/||g'`"; fi

		pkg-static rquery '%v' ${port} >/dev/null 2>/dev/null
		if [ $? -ne 0 ] ; then
			echo "Warning: Package missing for $PBI_CONFDIR ($port)"
			skip=1
			break
		fi
	done
	for port in ${PBI_MKPORTAFTER}
	do
  		# Cleanup $port
  		echo $port | grep -q "/$"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|/$||g'`"; fi
  		echo $port | grep -q "^/"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|^/||g'`"; fi

		pkg-static rquery '%v' ${port} >/dev/null 2>/dev/null
		if [ $? -ne 0 ] ; then
			echo "Warning: Package missing for $PBI_CONFDIR ($port)"
			skip=1
			break
		fi
	done
	if [ $skip -eq 1 ] ; then continue ; fi

	# Load any extra meta-data from the package
	load_pkg_metadata

	# Massage the descriptions to use html
	if [ -n "$PBI_PROGICON" ] ; then
		if [ -e "${PBI_CONFDIR}/resources/$PBI_PROGICON" ] ; then
			pI="`echo $PBI_MAKEPORT | sed 's|^/||g' | sed 's|/|-|g'`.png"
			cp "${PBI_CONFDIR}/resources/${PBI_PROGICON}" ${tIco}/$pI
		fi
	fi

	# Save this to the temporary INDEX file
	echo "PBI=${PBI_MAKEPORT}${d}${PBI_PROGNAME}${d}${PBI_MKPORTAFTER} ${PBI_MKPORTBEFORE}${d}${PBI_PROGAUTHOR}${d}${PBI_PROGWEB}${d}${PBI_LICENSE}${d}${PBI_PROGTYPE}${d}${PBI_CATEGORY}${d}${PBI_TAGS}${d}${PBI_MAINTAINER}${d}${PBI_SHORTDESC}${d}${PBI_DESC}${d}${PBI_SCREENSHOTS}${d}${PBI_RELATED}${d}${PBI_PLUGINS}${d}${PBI_CONTAINER}${d}" >> ${tI}

   done

   # Add the categories data
   cat PBI-categories >> ${tI}

   # Move the temp index
   mv ${tI} PBI-INDEX
   mv ${tIco} PBI-icons

   # Create the .txz file
   echo "Compressing PBI-INDEX..."
   tar cvJf ${PBI_INDEXFILE} --exclude ./.git --exclude ./${PBI_INDEXFILE} . >/dev/null 2>/dev/null

   # Sign this INDEX file
   openssl dgst -sha1 \
	-sign ${sKey} \
	-out ${PBI_INDEXFILE}.sha1 \
	${PBI_INDEXFILE}
   if [ $? -ne 0 ] ; then
      echo "ERROR: Failed to sign PBI repo.."
      exit 1
   fi

   exit 0
}

pbi_browser_init() {
	parse_browse_pbi_cmdline "$@"
	init_tmpdir

	# Check if we are doing a category listing, the default if no options
	if [ "$PBI_BROWSE_LISTCATS" = "YES" -o -z "${PBI_BROWSE_LISTALLPBI}${PBI_BROWSE_CAT}${PBI_BROWSE_SEARCH}" ] ; then
		pbi_browse_listcats
	else
		pbi_browse_listpbi
	fi

}

# List PBIs from a repo
pbi_browse_listpbi() {
	_rArch=`uname -m`

	# Figure out which type of display we are doing
	if [ -n "$PBI_BROWSE_LISTALLPBI" ] ; then
		echo "Using RepoID: $PBI_BROWSE_RID"
		echo "Listing all available PBIs"
		grep -i -e "^App=" $PBI_BROWSE_METAFILE > ${PBI_TMPDIR}/.meta.$$
	elif [ -n "$PBI_BROWSE_CAT" ] ; then
		echo "Using RepoID: $PBI_BROWSE_RID"
		echo "Available PBIs for Category: $PBI_BROWSE_CAT"
		grep -i -e "^App=" -i -e ";${PBI_BROWSE_CAT};" $PBI_BROWSE_METAFILE > ${PBI_TMPDIR}/.meta.$$
	elif [ -n "$PBI_BROWSE_SEARCH" ] ; then
		echo "Using RepoID: $PBI_BROWSE_RID"
		echo "Searching for: $PBI_BROWSE_SEARCH"
		grep -i -e "^App=" $PBI_BROWSE_METAFILE > ${PBI_TMPDIR}/.meta.$$
	else
		exit_err "No valid search variable set!"
	fi

	while read app
	do
		line=`echo $app | sed 's|^App=||g'`
		catCheck=`echo $line | cut -d ';' -f 2 2>/dev/null`
		aName=`echo $line | cut -d ';' -f 1 2>/dev/null`

		# Make sure this is from the correct category
		if [ -n "$PBI_BROWSE_CAT" ] ; then
			_cCheck=`echo $catCheck | tr '[:lower:]' '[:upper:]'`
			_cCheck2=`echo $PBI_BROWSE_CAT | tr '[:lower:]' '[:upper:]'`
			if [ "$_cCheck" != "$_cCheck2" ]; then 
			continue
			fi
		fi

		# Set the displayed arch type
		aArch="$_rArch"

		# Make sure this application has an associated PBI available
		check_pbi_update "$aName" "nodisplay" \
		 "$aName" "current" \
		 "$FBSDMAJOR" "$_rArch" "${PBI_BROWSE_RID}"
		if [ "$?" != "0" ] ; then
			# On amd64, see if 32bit version exists
			if [ "$_rArch" = "amd64" ] ; then
				check_pbi_update "$aName" "nodisplay" \
		 		"$aName" "current" \
		 		"$FBSDMAJOR" "i386" "${PBI_BROWSE_RID}"
				if [ "$?" != "0" ] ; then 
					continue
				else
					# Found a 32bit version of the app
					aArch="i386"
				fi
			else
				# Not on amd64, continue on
				continue
			fi
		fi

		aIcon=`echo $line | cut -d ';' -f 3`
		aAuthor=`echo $line | cut -d ';' -f 4`
		aUrl=`echo $line | cut -d ';' -f 5`
		aLic=`echo $line | cut -d ';' -f 6`
		aType=`echo $line | cut -d ';' -f 7`
		aKeywords=`echo $line | cut -d ';' -f 8`
		aDesc=`echo $line | cut -d ';' -f 9`
		aRoot=`echo $line | cut -d ';' -f 10`

		# Check for a translation to the description
		get_meta_trans "App" "$cName" "${PBI_BROWSE_METAFILE}"
		if [ -n "$MTRANS" ] ; then
			aDesc="$MTRANS"
		fi

		# Search the description / keywords
		if [ -n "$PBI_BROWSE_SEARCH" ] ; then
			echo "$aName,$aDesc,$aKeywords,$MTRANS" | grep -i "$PBI_BROWSE_SEARCH" >/dev/null 2>/dev/null
			if [ "$?" != "0" ]; then continue ; fi
		fi

		# Get the local icon file
		echo "------------------------------------"
		echo "Application: $aName"
		echo "Version: $PBI_UPNVER"
		if [ -n "$PBI_UPSIZE" ] ; then
			echo "Size: $PBI_UPSIZE"
		fi
		if [ -n "$PBI_BROWSE_LISTALLPBI" ] ; then
			echo "Category: $catCheck"
		fi
		echo "Created: `echo $PBI_UPMDATE`"
		if [ "$aRoot" = "YES" ] ; then
			echo "RootInstall: YES"
		else
			echo "RootInstall: NO"
		fi
		echo "Arch: $aArch"
		echo "Author: $aAuthor"
		echo "URL: $aUrl"
		echo "License: $aLic"
		echo "Type: $aType"
		echo "Keywords: $aKeywords"
		echo "Description: $aDesc"
		echo ""
		if [ "$aRoot" = "YES" ] ; then
			echo "To install this PBI (As Root):"
		else
			echo "To install this PBI:"
		fi
		echo "# pbi_add --rArch $aArch --repo $PBI_BROWSE_RID -r $aName"
		echo ""

		
	done < ${PBI_TMPDIR}/.meta.$$

}

# List available categories for this repository
pbi_browse_listcats() {

	echo "Using RepoID: $PBI_BROWSE_RID"
	echo "Available Categories:"
	grep "^Cat=" $PBI_BROWSE_METAFILE > ${PBI_TMPDIR}/.meta.$$
	while read cat
	do
		line=`echo $cat | sed 's|^Cat=||g'`
		cName=`echo $line | cut -d ';' -f 1`
		cIcon=`echo $line | cut -d ';' -f 2`
		cDesc=`echo $line | cut -d ';' -f 3`
		
		# Check for a translation to the description
		get_meta_trans "Cat" "$cName" "${PBI_BROWSE_METAFILE}"
		if [ -n "$MTRANS" ] ; then
			cDesc="$MTRANS"
		fi

		# Get the local icon file
		echo "------------------------------------"
		echo "Category: $cName"
		echo "Description: $cDesc"
		echo ""

	done < ${PBI_TMPDIR}/.meta.$$

	echo "To view available PBIs for a particular category:"
	echo " % pbi_browser -c <category> <repoid>"
}

# Function to check if we have a translated description
get_meta_trans() {
	local tag="$1"
	local name="$2"
	local metaFile="$3"

	# Check if we have a translation to overwrite with
	MTRANS=""
	if [ -z "$LANG" ] ; then return; fi

	lCheck="`echo $LANG | cut -d '_' -f 1` `echo $LANG | cut -d '.' -f 1`"
	for l in $lCheck
	do
		catTrans=`grep "^${tag}\[$l\]=${name}" ${metaFile}`	
		if [ -n "$catTrans" ] ; then
			MTRANS=`echo $catTrans | cut -d ";" -f 2`
			return
		fi
	done
}

# Lets check if this PBI exists in the indexdb
load_pbi_info_index()
{
	local tPBI="$1"
	d="::::"
	# No Database? Ain't gona find much..
	if [ ! -e "$PBI_INDEXDB" ] ; then return 1; fi
	
	# Look for an App= line
	local line=`cat ${PBI_INDEXDB} | grep "^PBI=" | grep -i "${d}${tPBI}${d}" | head -n 1`
	if [ -z "$line" ] ; then return 1 ; fi

	# Now get values from this list
	PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
	PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
	PBI_ORIGIN=`echo $line | awk -F:::: '{print $1}' | sed 's|PBI=||g'`
	PBI_PKGOTHER=`echo $line | awk -F:::: '{print $3}'`
	PBI_PROGAUTHOR=`echo $line | awk -F:::: '{print $4}'`
	PBI_PROGWEB=`echo $line | awk -F:::: '{print $5}'`
	PBI_PROGLICENSE=`echo $line | awk -F:::: '{print $6}'`
	PBI_PROGTYPE=`echo $line | awk -F:::: '{print $7}'`
	PBI_PROGCAT=`echo $line | awk -F:::: '{print $8}'`
	PBI_PROGMAINT=`echo $line | awk -F:::: '{print $10}'`
	PBI_SHORTDESC=`echo $line | awk -F:::: '{print $11}'`
	PBI_APPARCH=`uname -m`
	PBI_DESC=`echo $line | awk -F:::: '{print $12}'`
	PBI_PROGVERSION=`pkg-static rquery '%v' $PBI_ORIGIN`

	return 0
}

# Start the pbi_add process
pbi_add_init() {
	init_tmpdir
	parse_add_pbi_cmdline "$@"

	# If this isn't a container request, switch to package mode
	if [ "$PBI_DOCONTAINER" != "YES" ] ;then
		load_pbi_info_index "$PBI_FILENAME"
		if [ $? -ne 0 ] ; then
			exit_err "No such PBI: $PBI_FILENAME"
		fi
		if [ "$PBI_ADD_INFODISPLAY" = "YES" ] ; then
			check_pbi_info_display
			exit_trap
		fi
		do_pbi_pkg_add
		exit_trap
	fi

	# Check if we are only displaying information
	check_pbi_info_display
	check_pbi_gui_display
	check_pbi_scripts_display
	check_pbi_license_display
	check_pbi_meta_display
	if [ "$PBI_ADD_GUIDISPLAY" = "YES" -o "$PBI_ADD_INFODISPLAY" = "YES" -o "$PBI_CHECKSCRIPTS" = "YES" -o "${PBI_ADD_LICDISPLAY}" = "YES" -o "${PBI_ADD_METADISPLAY}" = "YES" ] 
	then 
		exit_trap
	fi

  	require_root

	check_agree_lic
	check_existing_pbi
	do_pbi_add
}

# Doing a PBI install via the package system
do_pbi_pkg_add() {
	echo "Installing: $PBI_FILENAME"

	# Make list of packages to install
	local _ins="$PBI_ORIGIN $PBI_PKGOTHER"
	local _toIns=""

	# See if this origin is already installed
	for i in $_ins
	do
		pkg-static query '%n' $i >/dev/null 2>/dev/null
		if [ $? -eq 0 ] ; then continue ; fi
		
		# Not installed! Lets Add it to the list
		_toIns="$_toIns $i"	
	done

	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Installing packages: $_toIns"
		dn=""	
	fi

	# Lets check for any conflicts doing this install
	check_pkg_conflicts "install -FUy ${_toIns}"
	if [ $? -ne 0 ] ; then
     		exit 1
  	fi

	# Now go forth and install these packages
	pkg install -yUf ${_toIns}
	if [ $? -ne 0 ] ; then
		exit_err "Failed installing: $PBI_FILENAME"
	fi

	exit 0
}

# Check if this PBI exists and exit if so
check_existing_pbi() {
	if [ "${PBI_EXTRACTONLY}" = "YES" ] ; then return 0; fi
	get_dbdir
	dir="${APPDBDIR}"

	# See if this PBI is already installed
	if [ -d "$dir" ]; then
		get_username_from_file "${APPDBDIR}/pbi_name"
		if [ "$FILEUSER" != `whoami` -a `id -u` != "0" ] ; then
			exit_err "Permission denied to modify PBI installed by: $FILEUSER"     
		fi

		if [ "${PBI_FORCEADD}" = "YES" ] ; then return 0; fi
		exit_err "${PBI_PROGNAME} ${PBI_PROGVERSION} is already installed! Use -f to force installation."
	fi

	if [ -e "${PBI_PROGDIRPATH}" ]; then
		get_username_from_file "${PBI_PROGDIRPATH}"
		if [ "$FILEUSER" != `whoami` -a `id -u` != "0" ] ; then
			exit_err "Permission denied to modify PBI installed by: $FILEUSER"     
		fi
		if [ "${PBI_FORCEADD}" = "YES" ] ; then return 0; fi
		exit_err "${PBI_PROGDIRPATH} already exists! Use -f to force installation."
	fi


}

# Check if we have a license to agree to, and if we've provided the flag to do so
check_agree_lic() {
        open_header_tmp
        if [ -f "${PBI_HEADER_TMPDIR}/${PBI_LICENSEFILE}" -a "${PBI_LICAGREE}" = "NO" ] ; then
        	delete_header_tmp
		exit_err "LICENSE must be agreed to (--licagree) before this PBI can be installed."
        fi
        delete_header_tmp
}

# See if we need to display pbi meta file
check_pbi_meta_display() {
	if [ "$PBI_ADD_METADISPLAY" != "YES" ] ; then return 0 ; fi
	open_header_tmp
	
	if [ -f "${PBI_HEADER_TMPDIR}/${PBI_USERMETAFILE}" ] ; then 
		cat "${PBI_HEADER_TMPDIR}/${PBI_USERMETAFILE}"	
	else
		echo "`basename $0`: No user metafile included with this PBI"
	fi
	delete_header_tmp
}

# See if we need to display pbi license
check_pbi_license_display() {
	if [ "$PBI_ADD_LICDISPLAY" != "YES" ] ; then return 0 ; fi
	open_header_tmp
	
	if [ -f "${PBI_HEADER_TMPDIR}/${PBI_LICENSEFILE}" ] ; then 
		echo "LICENSE:"
		cat "${PBI_HEADER_TMPDIR}/${PBI_LICENSEFILE}"	
	else
		echo "`basename $0`: No LICENSE included with this PBI"
	fi
	delete_header_tmp
}

# See if we need to display pbi info
check_pbi_info_display() {
	if [ "$PBI_ADD_INFODISPLAY" != "YES" ] ; then return 0 ; fi
	pbi_display_info
}

# Display pbi information to stdout
pbi_display_info() {

	tmp="`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`"
        _appname="${tmp}-${PBI_PROGVERSION}-${PBI_APPARCH}"

	echo "PBI Information for: $_appname"
	echo "-----------------------------------------------------"
	echo "Name: ${PBI_PROGNAME}"

	if [ -n "$PBI_INSTALLED_BY" ] ; then
		echo "InstalledBy: $PBI_INSTALLED_BY"
	fi

	# Does this PBI need root to install?
	if [ "$PBI_REQUIRESROOT" = "YES" -o "$PBI_CONTAINER" != "YES" ] ; then
		echo "RootInstall: YES"
	else
		echo "RootInstall: NO"
	fi

	echo "Version: ${PBI_PROGVERSION}"
	echo "Author: ${PBI_PROGAUTHOR}"
	echo "Website: ${PBI_PROGWEB}"
	echo "Arch: ${PBI_APPARCH}"
	echo "Description: ${PBI_SHORTDESC}"
	if [ "$PBI_CONTAINER" != "YES" ] ; then return; fi
	echo "Built: ${PBI_PROGMDATE}"
	echo "Prefix: ${PBI_ORIGPROGDIRPATH}"
	echo "FbsdVer: ${PBI_FBSDVER}"
	echo "CreatorVer: ${PBI_APPCREATEVER}"
	echo "ArchiveCount: ${PBI_ARCHIVE_COUNT}"
	echo "ArchiveSum: ${PBI_ARCHIVE_CHECKSUM}"
	case ${PBI_SIGVALID} in
		0) echo "Signature: Verified" ;;
  	       -1) echo "Signature: Not Signed" ;;
  	        1) echo "Signature: Bad" ;;
		*) echo "Signature: <Unknown>" ;;
	esac

	if [ -n "$PBI_LICENSE" ] ; then
		echo "License: $PBI_LICENSE"
	fi

	# See if we have any XDG stuff
	if [ -e "${PBI_ORIGPROGDIRPATH}/.xdg-desktop/install-desktop-icons.sh" ] ; then
		echo "DesktopIcons: YES"
	fi
	if [ -e "${PBI_ORIGPROGDIRPATH}/.xdg-menu/install-menu-icons.sh" ] ; then
		echo "MenuIcons: YES"
	fi
	if [ -e "${PBI_ORIGPROGDIRPATH}/.xdg-mime/install-mime.sh" ] ; then
		echo "MimeRegistration: YES"
	fi

	# If verbose mode, show file contents
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		if [ -n "${PBI_FILENAME}" -a -e "${PBI_FILENAME}" ] ; then
	  		pbi_find_archive_header
                	echo "TOTALFILES: ${PBI_ARCHIVE_COUNT}"
                	echo "Archive Contents:"
                	echo "--------------------------------------"
                	tail +$PBI_SKIP_ARCHLINES "${PBI_FILENAME}" | tar tvf - 
		fi
        fi
}

# See if we need to display gui header info
check_pbi_gui_display() {
	if [ "$PBI_ADD_GUIDISPLAY" != "YES" ] ; then return 0 ; fi
	open_header_tmp
	
	pbi_display_gui "$PBI_HEADER_TMPDIR" "COPY"

	delete_header_tmp

}

# Display location of PBI graphics
pbi_display_gui() {
	dir="$1"
	copy="$2"
	if [ -e "${dir}/top-banner.png" ] ; then 
		if [ "$copy" = "COPY" ] ; then
			pbi_guitop="/tmp/.PBI-top.$$.png"
			cp "${dir}/top-banner.png" "$pbi_guitop"
		else
			pbi_guitop="${dir}/top-banner.png"
		fi
		echo "TopBanner: ${pbi_guitop}"
	fi
	if [ -e "${dir}/side-banner.png" ] ; then 
		if [ "$copy" = "COPY" ] ; then
			pbi_guiside="/tmp/.PBI-side.$$.png"
			cp "${dir}/side-banner.png" "$pbi_guiside"
		else
			pbi_guiside="${dir}/side-banner.png"
		fi
		echo "SideBanner: ${pbi_guiside}"
	fi

	# Try to find an icon
	ls ${dir}/pbi_icon.* >/dev/null 2>/dev/null
	if [ "$?" = "0" ] ; then
		_iconExt=`ls ${dir}/pbi_icon.* | head -n 1 | awk -F . '{print $NF}'`
		if [ "$copy" = "COPY" ] ; then
			pbi_guiicon="/tmp/.PBI-icon.$$.${_iconExt}"
			cp "${dir}/pbi_icon.${_iconExt}" "$pbi_guiicon"
		else
			pbi_guiicon="${dir}/pbi_icon.${_iconExt}"
		fi
		echo "Icon: ${pbi_guiicon}"
	fi

}

open_header_tmp() {
	init_tmpdir

	# If we have a custom extract dir, use it
	if [ -z "$1" ] ; then
		PBI_HEADER_TMPDIR="${PBI_TMPDIR}/.PBI-header.$$"
	else
		PBI_HEADER_TMPDIR="${1}/.PBI-header.$$"
	fi

	if [ -e "${PBI_HEADER_TMPDIR}" ] ; then rm -rf "${PBI_HEADER_TMPDIR}" ; fi
	mkdir -p "${PBI_HEADER_TMPDIR}"
	
	# Extract the header files 
	tar xf "${PBI_FILENAME}" -C "${PBI_HEADER_TMPDIR}" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then exit_err "Failed to read PBI header! Possible corrupt PBI, or wrong PBI version for this OS." ; fi

}

delete_header_tmp() {
	if [ -z "${PBI_HEADER_TMPDIR}" ] ; then return 0 ; fi
	if [ -d "${PBI_HEADER_TMPDIR}" ] ; then rm -rf "${PBI_HEADER_TMPDIR}" ; fi
}

# Load in all the configuration data from the header
load_info_from_header() {
	open_header_tmp

	# Start loading our variables
	load_info_from_dir "${PBI_HEADER_TMPDIR}"

	delete_header_tmp
}

# See if we need to display scripts
check_pbi_scripts_display() {
	if [ "$PBI_CHECKSCRIPTS" != "YES" ] ; then return 0 ; fi

	# Display our scripts
	open_header_tmp
	if [ -e "${PBI_HEADER_TMPDIR}/${MOD_PREINS}" ] ; then
		echo -e "\n${MOD_PREINS}:"
		echo "--------------------------------"
		cat "${PBI_HEADER_TMPDIR}/${MOD_PREINS}"
	fi
	if [ -e "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}" ] ; then
		echo -e "\n${MOD_POSTINS}:"
		echo "--------------------------------"
		cat "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}"
	fi
	if [ -e "${PBI_HEADER_TMPDIR}/${MOD_PREREM}" ] ; then
		echo -e "\n${MOD_PREREM}:"
		echo "--------------------------------"
		cat "${PBI_HEADER_TMPDIR}/${MOD_PREREM}"
	fi
	delete_header_tmp
}

# Load pbi information from the specified directory
load_info_from_dir() {
	REQUIRED_FILES="pbi_defaultpath pbi_name pbi_version pbi_author pbi_web pbi_arch pbi_fbsdver pbi_createver"
	for f in $REQUIRED_FILES
	do
		if [ ! -e "${1}/${f}" ] ; then echo "Warning: Missing file: ${f}" ; fi
	done
        PBI_APPARCH=""
        PBI_APPCREATEVER=""
        PBI_ARCHIVE_CHECKSUM=""
        PBI_ARCHIVE_COUNT=""
        PBI_FBSDVER=""
	PBI_ORIGPROGDIRPATH=""
	PBI_PROGNAME=""
        PBI_PROGVERSION=""
        PBI_PROGAUTHOR=""
        PBI_PROGMDATE=""
        PBI_PROGWEB=""
	PBI_REQUIRESROOT=""
	PBI_SIGVALID=""
	PBI_DESC=""
	PBI_SHORTDESC=""
	PBI_MAINTAINER=""
	PBI_TAGS=""
	PBI_PROGTYPE=""
	PBI_CATEGORY=""
	PBI_ICONURL=""
	PBI_LICENSE=""

	PBI_ORIGPROGDIRPATH="`cat ${1}/pbi_defaultpath`"
        PBI_PROGNAME="`cat ${1}/pbi_name`"
        PBI_PROGVERSION="`cat ${1}/pbi_version`"
        PBI_PROGAUTHOR="`cat ${1}/pbi_author`"
        PBI_PROGWEB="`cat ${1}/pbi_web 2>/dev/null`"
        PBI_PROGMDATE="`cat ${1}/pbi_mdate 2>/dev/null`"
        PBI_APPARCH="`cat ${1}/pbi_arch 2>/dev/null`"
        PBI_FBSDVER="`cat ${1}/pbi_fbsdver 2>/dev/null`"
        PBI_APPCREATEVER="`cat ${1}/pbi_createver 2>/dev/null`"
        PBI_ARCHIVE_COUNT="`cat ${1}/pbi_archivecount 2>/dev/null`"
        PBI_ARCHIVE_CHECKSUM="`cat ${1}/pbi_archivesum 2>/dev/null`"

	if [ -e "${1}/pbi_license" ] ; then
                PBI_LICENSE="`cat ${1}/pbi_license`"
        fi
	if [ -e "${1}/pbi_tags" ] ; then
                PBI_TAGS="`cat ${1}/pbi_tags`"
        fi
	if [ -e "${1}/pbi_type" ] ; then
                PBI_PROGTYPE="`cat ${1}/pbi_type`"
        fi
	if [ -e "${1}/pbi_category" ] ; then
                PBI_CATEGORY="`cat ${1}/pbi_category`"
        fi
	if [ -e "${1}/pbi_iconurl" ] ; then
                PBI_ICONURL="`cat ${1}/pbi_iconurl`"
        fi
	if [ -e "${1}/pbi_desc" ] ; then
                PBI_DESC="`cat ${1}/pbi_desc | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
        fi
	if [ -e "${1}/pbi_shortdesc" ] ; then
                PBI_SHORTDESC="`cat ${1}/pbi_shortdesc | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
        fi
	if [ -e "${1}/pbi_maintainer" ] ; then
                PBI_MAINTAINER="`cat ${1}/pbi_maintainer`"
        fi

	# Does this PBI need to be installed as root
	if [ -e "${1}/pbi_requiresroot" ] ; then
		PBI_REQUIRESROOT="YES"
	fi
	
	# See if this PBI was signed
	if [ -e "${1}/pbi_archivesum.sha1" ] ; then
		check_valid_sigs "${1}"
		if [ "$?" = "0" ] ; then
			PBI_SIGVALID="0"
		else
			PBI_SIGVALID="1"
		fi
	else
		PBI_SIGVALID="-1"
	fi
}

# Start installing the PBI
do_pbi_add() {
	pbi_verify_signatures
	pbi_verify_archivesum

	check_preinstall_script

	mk_pbi_extract_dir
	pbi_extract_archive
	
	pbi_add_check_gids
	pbi_add_check_uids
	pbi_add_check_gids_users

	pbi_add_run_script
	check_postinstall_script

	pbi_add_register_app

	# Flush to disk
	sleep 0.5
	sync

}

# Check for any GIDs we need to create
pbi_add_check_gids_users() {
	if [ ! -e "${PBI_PROGDIRPATH}/${PBI_INS_GROUPSFILE}" ] ; then return ; fi
	runUID=`id -u`

	while read gidLine
	do
		gName=`echo $gidLine | cut -d ':' -f 1`
		gID=`echo $gidLine | cut -d ':' -f 3`
		gUsers=`echo $gidLine | cut -d ':' -f 4`

		if [ -n "$gUsers" ] ; then
			for gUser in `echo $gUsers | sed 's|,| |g'`
			do
				pw groupshow ${gName} | grep -qw ${gUser}
				if [ $? -ne 0 ] ; then
					# Are we installing as root?
					if [ "$runUID" != "0" ] ; then
						echo "Please add user \"$gUser\" to group \"$gName\" manually or re-install PBI as root."
						continue
					fi

					echo "Adding user ${gUser} to group ${gName}"
					pw groupmod ${gName} -m ${gUser}
				fi
			done
		fi
	done < ${PBI_PROGDIRPATH}/${PBI_INS_GROUPSFILE}
}


# Check for any GIDs we need to create
pbi_add_check_gids() {
	if [ ! -e "${PBI_PROGDIRPATH}/${PBI_INS_GROUPSFILE}" ] ; then return ; fi
	runUID=`id -u`

	while read gidLine
	do
		gName=`echo $gidLine | cut -d ':' -f 1`
		gID=`echo $gidLine | cut -d ':' -f 3`
		gUsers=`echo $gidLine | cut -d ':' -f 4`

		# Is this group already on the system?
		pw groupshow $gName >/dev/null 2>/dev/null
		if [ $? -eq 0 ] ; then
			echo "Using existing group: $gName"
		else
			# Are we installing as root?
			if [ "$runUID" != "0" ] ; then
				echo "Please create group \"$gName\" manually or re-install PBI as root."
			else
				echo "Adding group: $gName"
				pw groupadd $gName -g $gID;
			fi
		fi
	done < ${PBI_PROGDIRPATH}/${PBI_INS_GROUPSFILE}
}

# Check for any UIDs we need to create
pbi_add_check_uids() {
	if [ ! -e "${PBI_PROGDIRPATH}/${PBI_INS_USERSFILE}" ] ; then return ; fi
	runUID=`id -u`

	while read uidLine
	do
		uName=`echo $uidLine | cut -d ':' -f 1`

		# Is this user already on the system?
		pw usershow $uName >/dev/null 2>/dev/null
		if [ $? -eq 0 ] ; then echo "Using existing user: $uName"; continue ; fi

		# Are we installing as root?
		if [ "$runUID" != "0" ] ; then
			echo "Please create user \"$uName\" manually or re-install PBI as root."
			continue
		fi

		uID=`echo $uidLine | cut -d ':' -f 3`
		gID=`echo $uidLine | cut -d ':' -f 4`
		uClass=`echo $uidLine | cut -d ':' -f 5`
		uGecos=`echo $uidLine | cut -d ':' -f 8`
		uHomedir=`echo $uidLine | cut -d ':' -f 9 | sed "s|^/usr/local|${PBI_PROGDIRPATH}|"`
		uShell=`echo $uidLine | cut -d ':' -f 10`

		echo "Adding user: $uName"
		pw useradd $uName -u $uID -g $gID $uClass -c "$uGecos" -d $uHomedir -s $uShell;

		# Create homedir
		case $uHomedir in 
			/nonexistent|/var/empty) ;; 
			*) install -d -g $gID -o $uID $uHomedir ;;
		esac 
	done < ${PBI_PROGDIRPATH}/${PBI_INS_USERSFILE}
}

# Run the install script if exists
pbi_add_run_script() {

	# If running as user, add bin path-links
	if [ "`id -u`" != "0" ] ; then add_app_path_links "${PBI_PROGDIRPATH}" ; fi

	insc="${PBI_PROGDIRPATH}/${PBI_FAKEBIN_DIR}/.pbi-install.sh"
	if [ ! -e "${insc}" ] ; then return 0 ; fi
	export_script_vars
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		${insc}
	else
		${insc} >/dev/null 2>/dev/null
	fi

}

# Return the dbdir for this PBI
get_dbdir() {
	tmp="`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`"
        APPDBDIR="${PBI_DBAPPDIR}/${tmp}-${PBI_PROGVERSION}-${PBI_APPARCH}"
}

# Register this app as installed
pbi_add_register_app() {
	if [ ! -d "$PBI_DBAPPDIR" ] ; then mkdir -p ${PBI_DBAPPDIR} ; fi
        open_header_tmp
	get_dbdir
	dir="${APPDBDIR}"

	# Make sure we remove any existing meta-data if forcing an installation
	if [ "$PBI_FORCEADD" = "YES" ] ; then
	  	tmp="`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`"
          	rm -rf ${PBI_DBAPPDIR}/${tmp}-*-${PBI_APPARCH}
	fi

	mkdir -p "${dir}"
	
        tar cf - -C "${PBI_HEADER_TMPDIR}" . 2>/dev/null | tar xvf - -C "$dir" 2>/dev/null

	echo "${PBI_PROGDIRPATH}" >${dir}/pbi_installedpath

        delete_header_tmp

	echo "Installed: ${PBI_PROGNAME}-${PBI_PROGVERSION}"
}

# Check if we have a postinstall script we need to use
check_postinstall_script() {
        open_header_tmp

        if [ ! -e "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}" ] ; then
                delete_header_tmp
                return 0
        fi

        export_script_vars
        sh "${PBI_HEADER_TMPDIR}/${MOD_POSTINS}"
        delete_header_tmp
}

# Check if we have a preinstall script we need to use
check_preinstall_script() {
	open_header_tmp

	if [ ! -e "${PBI_HEADER_TMPDIR}/${MOD_PREINS}" ] ; then 
		delete_header_tmp
		return 0 
	fi

	export_script_vars
	sh "${PBI_HEADER_TMPDIR}/${MOD_PREINS}"
	if [ "$?" != "0" ] ; then
        	delete_header_tmp
		exit_err "${MOD_PREINS} returned error status"
	fi
        delete_header_tmp
}

# Verify if we have valid openssl signatures on important parts of PBI
pbi_verify_signatures() {
	if [ "${PBI_SKIPSIGVERIFY}" = "YES" ] ; then return 0 ; fi
	if [ "$PBI_SIGVALID" = "0" ] ; then return ; fi
	if [ "$PBI_SIGVALID" = "1" ] ; then kw="Invalid" ; else kw="No" ; fi
	exit_err "$kw digital signature! If you are *SURE* you trust this PBI, re-install with --no-checksig option. "

}

# Check if we have valid signature on this file
check_file_sig() {
	good="true"
        openssl dgst -sha1 \
                      -verify ${PBI_SHARE_DIR}/repokey.ssl \
                      -signature ${1}.sha1 \
                      ${1} >/dev/null 2>/dev/null
	return $?	
}

# Check if we have valid signatures, and return "0" if success, "1" if failure
check_valid_sigs() {
	PBI_VALIDKEYSIG=""

	for _pk in ${PBI_PUBKEYS}
	do
		good="true"
		_sf="${1}/pbi_archivesum ${1}/${MOD_PREINS} ${1}/${MOD_POSTINS} ${1}/${MOD_PREREM}"
       		for _ts in $_sf
        	do
                	openssl dgst -sha1 \
                        -verify ${_pk} \
                        -signature ${_ts}.sha1 \
                        ${_ts} >/dev/null 2>/dev/null
			if [ "$?" != "0" ] ; then
				good="false" ; break
			fi
			PBI_VALIDKEYSIG="$_pk"
		done
		if [ "$good" = "true" ] ; then return 0 ; fi
        done
	return 1	
}

# Verify if the archive checksum is good
pbi_verify_archivesum() {
	if [ "${PBI_SKIPCHECKSUM}" = "YES" ] ; then return 0 ; fi
	echo -e "Verifying Checksum...\c"

        pbi_find_archive_header
	sum=`tail +$PBI_SKIP_ARCHLINES "${PBI_FILENAME}" | sha256 -q`
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Archive checksum: ${sum}"
		echo "Saved checksum: ${PBI_ARCHIVE_CHECKSUM}"
	fi
	if [ "$sum" != "$PBI_ARCHIVE_CHECKSUM" ] ; then
		exit_err "${PBI_FILENAME} failed checksum, the archive may be corrupt."
	fi
	echo -e "OK"

}

# Make our PBI extraction dir
mk_pbi_extract_dir() {
	PBI_EXTRACTDIR="${PBI_PROGDIRPATH}"
	if [ -e "${PBI_EXTRACTDIR}" ] ; then
               rm -rf "$PBI_EXTRACTDIR"
	fi
	mkdir -p "${PBI_EXTRACTDIR}" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then 
		exit_err "Failed to create directory: ${PBI_PROGDIRPATH}"
	fi
}

pbi_find_archive_header() {
	# Find the header for the archive
	# SEARCH FOR: $PBI_SS_ARCHIVE
	PBI_SKIP_ARCHLINES=`awk "/^${PBI_SS_ARCHIVE}/ { print NR + 1; exit 0; }" "${PBI_FILENAME}"`
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "SKIP_ARCHLINES: $PBI_SKIP_ARCHLINES"
	fi
}

# Extract the PBI archive file
pbi_extract_archive() {
	pbi_find_archive_header	

	echo "Extracting to: ${PBI_EXTRACTDIR}"

	if [ "$PBI_VERBOSE" = "YES" ] ; then
		tar="xvf -"
		echo "TOTALFILES: ${PBI_ARCHIVE_COUNT}"
		tail +$PBI_SKIP_ARCHLINES "${PBI_FILENAME}" | tar ${tar} -C "${PBI_EXTRACTDIR}"
		err="$?"
	else
		tar="xf -"
		tail +$PBI_SKIP_ARCHLINES "${PBI_FILENAME}" | tar ${tar} -C "${PBI_EXTRACTDIR}" 2>/dev/null
		err="$?"
	fi
	if [ "$err" != "0" ] ; then exit_err "Failed extracting ${PBI_FILENAME}" ; fi

	if [ "$PBI_VERBOSE" = "YES" ] ; then echo "Extraction Finished!" ; fi

	# If this is an extract only, do it and exit
	if [ "${PBI_EXTRACTONLY}" = "YES" ] ; then exit_trap ; fi
}
	

# Starting pbi_create
pbi_create_init() {

	require_root

	parse_create_pbi_cmdline "$@"

	# If we are making a backup copy of an installed PBI
	if [ "$PBI_CBACKUP" = "YES" ] ; then
		init_tmpdir
		do_pbi_create_backup
		exit_trap
	fi

	load_pbi_conffile

	parse_cmdline_overrides

	# Copy over the application to the correct location
        echo ${PBI_PROGDIRPATH} | grep -q "^${PBI_APPDIR}/"
	if [ $? -ne 0 ] ; then
	   _pbilow="`echo ${PBI_PROGNAME} | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
	   newPDP="${PBI_APPDIR}/${_pbilow}-${ARCH}"
	   if [ -d "${newPDP}" ] ; then exit_err "Error: ${newPDP} already exists!" ; fi	
	   cp -r ${PBI_PROGDIRPATH} ${newPDP}
	   PBI_PROGDIRPATH="${newPDP}"
	   export PBI_PROGDIRPATH
	fi

	PBI_CREATEONLY="YES"

	check_create_required_vars

	do_pbi_create

	# Cleanup the copy dir
 	if [ -n "$newPDP" ] ; then
		if [ "${newPDP}" != "/" -a "${newPDP}" != "${PBI_APPDIR}/-" ] ; then
			rm -rf "${newPDP}"
		fi
	fi
}

# Start the pbi_create backup process
do_pbi_create_backup() {

	load_info_from_dir "${PBI_DBAPPDIR}/${PBI_CBACKUPTARGET}"
	echo "Creating backup PBI: ${PBI_PROGNAME}-${PBI_PROGVERSION}"

	# Start by making a fresh archive of the installed PBI
	PBI_STAGEDIR="$PBI_ORIGPROGDIRPATH"
	mk_archive_file

	# Now make the header dir
	_hDir="${PBI_TMPDIR}/.header.$$"
	PBI_HEADERDIR="${_hDir}"
	mkdir -p "${_hDir}"
	cp ${PBI_DBAPPDIR}/${PBI_CBACKUPTARGET}/* "${_hDir}"
	rm ${_hDir}/*.sha1 >/dev/null 2>/dev/null

	# Get the total number of files in the STAGEDIR
	get_filetotal_dir "${PBI_STAGEDIR}"
	echo "${FILETOTAL}" > "${PBI_HEADERDIR}/pbi_archivecount"

	# Save a checksum of archive file
	sha256 -q "${PBI_CREATE_ARCHIVE}" > "${PBI_HEADERDIR}/pbi_archivesum"

	# Sign any header files
	sign_pbi_files "$PBI_HEADERDIR"

	# Make the header archive
	mk_header_file

	# Now finish up and make the resulting PBI file
	mk_output_pbi

}


# Vars required for creation
check_create_required_vars() {
	if [ -z "${PBI_PROGNAME}" ] ; then exit_err "Missing PBI_PROGNAME"; fi
	if [ -z "${PBI_PROGVERSION}" ] ; then exit_err "Missing PBI_PROGVERSION"; fi
	if [ -z "${PBI_PROGAUTHOR}" ] ; then exit_err "Missing PBI_PROGAUTHOR"; fi
	if [ -z "${PBI_PROGWEB}" ] ; then exit_err "Missing PBI_PROGWEB"; fi
}

# Start the pbi_create process
do_pbi_create() {
	get_pbi_progname
	echo "Creating PBI: ${PBI_PROGNAME}-${PBI_PROGVERSION}"


	if [ "`basename $0`" = "pbi_makeport" -o "`basename $0`" = "pbi_makeport_chroot" ] ; then
	  mk_stage_dir "/usr/local" "move"

	  # Check if we created a linux app, and need to copy files for it
	  auto_copy_linuxbase
	else
	  mk_stage_dir
	fi

	copy_resource_dir
	clean_stage_dir

	mk_extlink_entries
	clean_icons_dir
	mk_xdg_scripts

	# Check for any users / groups we need to save for install time
	mk_pbi_users_file
	mk_pbi_groups_file

	run_pbi_prepkgscript

	mk_install_script
	mk_deinstall_script

	mk_archive_file

	mk_header_dir
 	save_pbi_details_to_header
	mk_header_file

	mk_output_pbi

	rm_stage_dir
	exit 0
}

# Parse any external link directives
mk_extlink_entries() {
	echo "Creating external link entries..."
	init_tmpdir
	_extf="${PBI_CONFDIR}/${MOD_EXTLINKFILE}"
	_autoextf="${PBI_TMPDIR}/${MOD_AUTOEXTLINKFILE}"
	_tmpextf="${PBI_TMPDIR}/${MOD_AUTOEXTLINKFILE}.$$"
  	if [ ! -e "${_extf}" -a ! -e "${_autoextf}" ] ; then return 0 ; fi

	dir="${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}"
        if [ ! -d "${dir}" ] ; then mkdir -p "${dir}" ; fi

	# Create the headers for the PATH link scripts
        echo "#!/bin/sh" >"${dir}/${PBI_INS_PATHSCRIPT}"
        echo "#!/bin/sh" >"${dir}/${PBI_UNINS_PATHSCRIPT}"

	# Make sure we also set SYS_LOCALBASE in case user runs these stand-alone at some point
        echo "if [ -z \"\$SYS_LOCALBASE\" ]; then SYS_LOCALBASE=\"${SYS_LOCALBASE}\" ; fi" >>"${dir}/${PBI_INS_PATHSCRIPT}"
        echo "if [ -z \"\$SYS_LOCALBASE\" ]; then SYS_LOCALBASE=\"${SYS_LOCALBASE}\" ; fi" >>"${dir}/${PBI_UNINS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_RCDIR\" ]; then PBI_RCDIR=\"${PBI_RCDIR}\" ; fi" >>"${dir}/${PBI_INS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_RCDIR\" ]; then PBI_RCDIR=\"${PBI_RCDIR}\" ; fi" >>"${dir}/${PBI_UNINS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_MANDIR\" ]; then PBI_MANDIR=\"${PBI_MANDIR}\" ; fi" >>"${dir}/${PBI_INS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_MANDIR\" ]; then PBI_MANDIR=\"${PBI_MANDIR}\" ; fi" >>"${dir}/${PBI_UNINS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_BINDIR\" ]; then PBI_BINDIR=\"${PBI_BINDIR}\" ; fi" >>"${dir}/${PBI_INS_PATHSCRIPT}"
        echo "if [ -z \"\$PBI_BINDIR\" ]; then PBI_BINDIR=\"${PBI_BINDIR}\" ; fi" >>"${dir}/${PBI_UNINS_PATHSCRIPT}"

	touch "$_tmpextf"
	if [ -e "$_autoextf" ]; then cat "${_autoextf}" >> "${_tmpextf}" ; fi
	if [ -e "$_extf" ]; then cat "${_extf}" >> "${_tmpextf}" ; fi

        while read line
        do
		_bin="NO"
		_wraponly="NO"
		_crashhandle="YES"
		_keep="YES"
		_linux="NO"
                echo $line | tr '\t' ' ' | tr -s ' ' | grep "^#" >/dev/null 2>/dev/null
                if [ "$?" != "0" ] ; then
                        src="`echo $line | tr '\t' ' ' | tr -s ' ' | cut -d ' ' -f 1`"
                        tar="`echo $line | tr '\t' ' ' | tr -s ' ' | cut -d ' ' -f 2`"
                        act="`echo $line | tr '\t' ' ' | tr -s ' ' | cut -d ' ' -f 3`"

			if [ -z "$src" -o -z "$tar" ] ; then continue ; fi

			# Check if this is an icon we need to preserve
			echo $src | grep -q "^share/icons/"
			if [ $? -eq 0 -a "${PBI_USESYSFONTS}" != "NO" ] ; then
				iDir=`dirname $src`
				if [ ! -d "${PBI_STAGEDIR}/${PBI_ICDIR}/${iDir}" ] ; then 
					mkdir -p "${PBI_STAGEDIR}/${PBI_ICDIR}/${iDir}"
				fi
				cp "${PBI_STAGEDIR}/${src}" "${PBI_STAGEDIR}/${PBI_ICDIR}/${iDir}"
				src="${PBI_ICDIR}/${src}"
			fi

			if [ ! -e "${PBI_STAGEDIR}/$src" ] ; then
				echo "WARN: external_link target: \"$src -> $tar $act\" does not exist!"
				continue
			fi

			# Check for act directives
			for i in `echo ${act} | sed 's|,| |g'`
  			do
				case ${i} in
					binary) _bin="YES" ;;
	  			    binwrapper) _bin="YES" ; _wraponly="YES" ;;
				       nocrash) _crashhandle="NO" ;;
				          keep) _keep="YES" ;;
				       replace) _keep="NO" ;;
				         linux) _bin="YES" ; _linux="YES" ;;
					*) echo "Warning: Unknown option \"$i\" in ${MOD_EXTLINKFILE}";;
				esac
				
			done


			# If we are doing a binary, run special function to make wrapper
			if [ "$_bin" = "YES" ] ; then

				# Make sure we don't create any duplicates
				echo "$_donewrap" | grep "#${src}#" >/dev/null 2>/dev/null
				if [ "$?" = "0" ] ; then continue ; fi
				
				# Make the binary wrapper
				mk_path_wrappers "$src" "$tar" "$_crashhandle" "$_wraponly" "$_linux"

				# This binary is done, save it now so we don't duplicate later
				_donewrap="$_donewrap #${src}#"
			else
				# Make our link commands
				if [ "$_keep" = "YES" ] ; then _lop="-fs"; else _lop="-s"; fi
				echo $tar | grep -q "^man/"
				if [ $? -eq 0 ] ; then
					# Strip off the man/ path
					_mTar=`echo $tar | sed 's|^man/||g'`
					_dTar="\$PBI_MANDIR/${_mTar}"
					echo "_bd=\"\`dirname ${_dTar}\`\"" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "if [ ! -d \"\$_bd\" ]; then mkdir -p \"\${_bd}\"; fi" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "if [ -e \"\$PBI_PROGDIRPATH/local/$src\" ]; then" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "  ln ${_lop} $PBI_PROGDIRPATH/local/${src} \$PBI_MANDIR/${_mTar}" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "fi" >> "${dir}/${PBI_INS_PATHSCRIPT}"
				else
					_dTar="\$SYS_LOCALBASE/${tar}"
					echo "_bd=\"\`dirname ${_dTar}\`\"" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "if [ ! -d \"\$_bd\" ] ; then mkdir -p \"\${_bd}\"; fi" >> "${dir}/${PBI_INS_PATHSCRIPT}"
					echo "ln ${_lop} $PBI_PROGDIRPATH/local/${src} \$SYS_LOCALBASE/${tar}" >> "${dir}/${PBI_INS_PATHSCRIPT}"

				fi
			fi

			# Make the uninstall command
			echo "ls -al \"${_dTar}\" | grep \"> $PBI_PROGDIRPATH\" >/dev/null 2>/dev/null " \
				>> "${dir}/${PBI_UNINS_PATHSCRIPT}"
			echo "if [ \"\$?\" = \"0\" ] ; then" >> "${dir}/${PBI_UNINS_PATHSCRIPT}"
			echo "	rm \"${_dTar}\"" >> "${dir}/${PBI_UNINS_PATHSCRIPT}"
			echo "fi" >> "${dir}/${PBI_UNINS_PATHSCRIPT}"

			echo " " >> "${dir}/${PBI_INS_PATHSCRIPT}"
			echo " " >> "${dir}/${PBI_UNINS_PATHSCRIPT}"

                fi

        done < "${_tmpextf}"
	rm "${_tmpextf}"

	chmod 755 "${dir}/${PBI_INS_PATHSCRIPT}"
	chmod 755 "${dir}/${PBI_UNINS_PATHSCRIPT}"
}


# Create the wrapper scripts for the specified binaries 
mk_path_wrappers() {
	dir="${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}"
	rcdir="${PBI_STAGEDIRMNT}/${PBI_FAKERC_DIR}"
        if [ ! -d "${dir}" ] ; then mkdir -p "${dir}" ; fi

	bin="${1}"
	fbin="`basename ${bin}`"
	tar="${2}"
	ch="${3}"
	onlywrap="${4}"
	linwrap="${5}"

	# Check if the fake-bin wrapper already exists, and if so use
	# a different name
	if [ -e "${dir}/${fbin}" ] ; then
		fbin=`echo $bin | sed 's|/|-|g'`
	fi

	# If this is an rc.d script, add it to the PBI_RCDIR
	if [ "`dirname $tar`" = "etc/rc.d" ] ; then
			>> "${dir}/${PBI_INS_PATHSCRIPT}"
		_dTar="\$PBI_RCDIR/`basename ${tar}`"
		echo "_bd=\"\`dirname ${_dTar}\`\"" >> "${dir}/${PBI_INS_PATHSCRIPT}"
		echo "if [ ! -d \"\$_bd\" ] ; then mkdir -p \"\${_bd}\"; fi" >> "${dir}/${PBI_INS_PATHSCRIPT}"
		echo "ln -fs $PBI_PROGDIRPATH/${PBI_FAKERC_DIR}/${fbin} \$PBI_RCDIR/`basename ${tar}`" >> "${dir}/${PBI_INS_PATHSCRIPT}"

		# Copy the wrapper binary
		PBI_WRAPPERFILE="/.pbiwrapper-$ARCH"
		cp ${PBI_WRAPPERFILE} ${rcdir}/${fbin}
		chmod 755 ${rcdir}/${fbin}

		# Create the wrapper .pbiopt
		echo "PROGDIR: ${PBI_PROGDIRPATH}" >${rcdir}/${fbin}.pbiopt
		echo "TARGET: ${bin}" >>${rcdir}/${fbin}.pbiopt
		return
	fi

	# Make our link to the system localbase if its not a wrapper only
 	if [ "$onlywrap" != "YES" ] ; then	
		_mTar=`echo $tar | sed "s|^bin/||g" | sed "s|^sbin/||g"`
		_dTar="\$PBI_BINDIR/${_mTar}"

			>> "${dir}/${PBI_INS_PATHSCRIPT}"
		echo "_bd=\"\`dirname ${_dTar}\`\"" >> "${dir}/${PBI_INS_PATHSCRIPT}"
		echo "if [ ! -d \"\$_bd\" ] ; then mkdir -p \"\${_bd}\"; fi" >> "${dir}/${PBI_INS_PATHSCRIPT}"
		echo "ln -fs $PBI_PROGDIRPATH/${PBI_FAKEBIN_DIR}/${fbin} \$PBI_BINDIR/${_mTar}" >> "${dir}/${PBI_INS_PATHSCRIPT}"
	fi


	# Copy the wrapper binary
	PBI_WRAPPERFILE="/.pbiwrapper-$ARCH"
	cp ${PBI_WRAPPERFILE} ${dir}/${fbin}
	chmod 755 ${dir}/${fbin}

	# Create the wrapper .pbiopt
	echo "PROGDIR: ${PBI_PROGDIRPATH}" >${dir}/${fbin}.pbiopt
	echo "TARGET: ${bin}" >>${dir}/${fbin}.pbiopt
}

# Create any XDG script for install / deinstall
mk_xdg_scripts() {
 	echo "Creating xdg scripts..."
  	mk_xdg_desktop_script
  	mk_xdg_menu_script
  	mk_xdg_mime_script
}

# Create any XDG script for desktop icons
mk_xdg_desktop_script() {
  	if [ ! -d "${PBI_CONFDIR}/${MOD_XDGDESK_DIR}" ] ; then return 0 ; fi
	_dFound=0

	dir="${PBI_STAGEDIRMNT}/${PBI_APPDESK_DIR}"
	if [ ! -d "${dir}" ] ; then mkdir -p "${dir}" ; fi
	echo "#!/bin/sh" >"${dir}/${PBI_INS_DESKSCRIPT}"
	echo "#!/bin/sh" >"${dir}/${PBI_UNINS_DESKSCRIPT}"

  	cd "${PBI_CONFDIR}/${MOD_XDGDESK_DIR}"
  	for i in `ls *.desktop 2>/dev/null`
  	do
		_dFound=1

		# Copy over the .desktop file, modifying any variables within
	        cat "${i}" \
           	| sed "s|%%PBI_EXEDIR%%|$PBI_PROGDIRPATH/$PBI_FAKEBIN_DIR|g" \
		| sed "s|%%PBI_APPDIR%%|${PBI_PROGDIRPATH}/local|g" \
		> "${dir}/PBI-${i}"

		# Set the correct permissions on the desktop file
		chmod 744 "${dir}/PBI-${i}"

		ifi="$PBI_PROGDIRPATH/${PBI_APPDESK_DIR}/PBI-${i}"

		echo "xdg-desktop-icon install --novendor ${ifi}" \
			 >> "${dir}/${PBI_INS_DESKSCRIPT}"
		echo "xdg-desktop-icon uninstall ${ifi}" \
			 >> "${dir}/${PBI_UNINS_DESKSCRIPT}"
		
  	done

	chmod 755 "${dir}/${PBI_INS_DESKSCRIPT}"
	chmod 755 "${dir}/${PBI_UNINS_DESKSCRIPT}"

	# No desktop entries
        if [ "$_dFound" = "0" ] ; then
                rm "${dir}/${PBI_INS_DESKSCRIPT}"
                rm "${dir}/${PBI_UNINS_DESKSCRIPT}"
        fi
}

# Create any XDG script for menu icons
mk_xdg_menu_script() {
  	if [ ! -d "${PBI_CONFDIR}/${MOD_XDGMENU_DIR}" ] ; then return 0 ; fi

	_mFound=0

	dir="${PBI_STAGEDIRMNT}/${PBI_APPMENU_DIR}"
        if [ ! -d "${dir}" ] ; then mkdir -p "${dir}" ; fi
        echo "#!/bin/sh" >"${dir}/${PBI_INS_MENUSCRIPT}"
        echo "#!/bin/sh" >"${dir}/${PBI_UNINS_MENUSCRIPT}"

  	cd "${PBI_CONFDIR}/${MOD_XDGMENU_DIR}"
  	for i in `ls *.desktop 2>/dev/null`
  	do
		_mFound=1

		# Copy the desktop file, changing any included vars
	        cat "${i}" \
           	| sed "s|%%PBI_EXEDIR%%|$PBI_PROGDIRPATH/$PBI_FAKEBIN_DIR|g" \
		| sed "s|%%PBI_APPDIR%%|${PBI_PROGDIRPATH}/local|g" \
		> "${dir}/PBI-${i}"

		# Set the correct permissions on the menu file
		chmod 744 "${dir}/PBI-${i}"

		ifi="$PBI_PROGDIRPATH/${PBI_APPMENU_DIR}/PBI-${i}"

		# Check for a .directory file associated with this .desktop
		ifd=""
		dirfile="`basename -s .desktop ${i}`"
		if [ -e "${dirfile}.directory" ] ; then
	        	cat "${dirfile}.directory" \
           		| sed "s|%%PBI_EXEDIR%%|$PBI_PROGDIRPATH/$PBI_FAKEBIN_DIR|g" \
			| sed "s|%%PBI_APPDIR%%|${PBI_PROGDIRPATH}/local|g" \
			> "${dir}/PBI-${dirfile}.directory"
			#cp "${dirfile}.directory" "${dir}/PBI-${dirfile}.directory"
			ifd="$PBI_PROGDIRPATH/${PBI_APPMENU_DIR}/PBI-${dirfile}.directory "	
		fi

		echo "xdg-desktop-menu install --novendor ${ifd}${ifi}" \
			 >> "${dir}/${PBI_INS_MENUSCRIPT}"
		echo "xdg-desktop-menu uninstall ${ifd}${ifi}" \
			 >> "${dir}/${PBI_UNINS_MENUSCRIPT}"

  	done

	# Update the mime databases now
	echo "update-mime-database" >> "${dir}/${PBI_INS_MENUSCRIPT}"
	echo "update-mime-database" >> "${dir}/${PBI_UNINS_MENUSCRIPT}"

	chmod 755 "${dir}/${PBI_INS_MENUSCRIPT}"
	chmod 755 "${dir}/${PBI_UNINS_MENUSCRIPT}"

	# No mime entries
        if [ "$_mFound" = "0" ] ; then
                rm "${dir}/${PBI_INS_MENUSCRIPT}"
                rm "${dir}/${PBI_UNINS_MENUSCRIPT}"
        fi
}

# Create any XDG script for mime types
mk_xdg_mime_script() {
  	if [ ! -d "${PBI_CONFDIR}/${MOD_XDGMIME_DIR}" ] ; then return 0 ; fi
	_mFound=0

        dir="${PBI_STAGEDIRMNT}/${PBI_APPMIME_DIR}"
        if [ ! -d "${dir}" ] ; then mkdir -p "${dir}" ; fi
        echo "#!/bin/sh" >"${dir}/${PBI_INS_MIMESCRIPT}"
        echo "#!/bin/sh" >"${dir}/${PBI_UNINS_MIMESCRIPT}"


  	cd "${PBI_CONFDIR}/${MOD_XDGMIME_DIR}"
  	for i in `ls *.xml 2>/dev/null`
  	do
		_mFound=1
		cp "${i}" "${dir}/PBI-${i}"
		ifi="$PBI_PROGDIRPATH/${PBI_APPMIME_DIR}/PBI-${i}"

		# Check for a .directory file associated with this .desktop
		ifp=""
		iconfile="`basename -s .xml ${i}`"
		if [ -e "${iconfile}.png" ] ; then
			cp "${iconfile}.png" "${dir}/${iconfile}.png"
			ifp="$PBI_PROGDIRPATH/${PBI_APPMIME_DIR}/${iconfile}.png"
			mi=`cat "$i" | grep '<mime-type' | cut -d '"' -f 2 | sed 's|/|-|g'`
			echo "xdg-icon-resource install --novendor --context mimetypes ${ifp} --size 64 $mi" \
				 >> "${dir}/${PBI_INS_MIMESCRIPT}"
			echo "xdg-icon-resource uninstall --context mimetypes ${ifp} --size 64" \
				 >> "${dir}/${PBI_UNINS_MIMESCRIPT}"
		fi

		echo "xdg-mime install --novendor ${ifi}" \
			 >> "${dir}/${PBI_INS_MIMESCRIPT}"
		echo "xdg-mime uninstall ${ifi}" \
			 >> "${dir}/${PBI_UNINS_MIMESCRIPT}"
  	done

	# Update the mime databases now
	echo "update-mime-database" >> "${dir}/${PBI_INS_MIMESCRIPT}"
	echo "update-mime-database" >> "${dir}/${PBI_UNINS_MIMESCRIPT}"

	chmod 755 "${dir}/${PBI_INS_MIMESCRIPT}"
	chmod 755 "${dir}/${PBI_UNINS_MIMESCRIPT}"

	# No mime entries
	if [ "$_mFound" = "0" ] ; then
		rm "${dir}/${PBI_INS_MIMESCRIPT}"
		rm "${dir}/${PBI_UNINS_MIMESCRIPT}"
	fi
}


# Create the install script for the PBI
mk_install_script() {
	echo "Creating install script..."
	if [ ! -d "${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}" ] ; then mkdir -p "${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}" ; fi
	if [ ! -d "${PBI_STAGEDIRMNT}/${PBI_FAKERC_DIR}" ] ; then mkdir -p "${PBI_STAGEDIRMNT}/${PBI_FAKERC_DIR}" ; fi
	insc="${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}/.pbi-install.sh"
	echo "#!/bin/sh" > "$insc"
	echo "PBI_WRAPPERBIN=\"${PBI_FAKEBIN_DIR}\"" >> "$insc"
	echo "PBI_PROGDIRPATH=\"${PBI_PROGDIRPATH}\"" >> "$insc"
	echo "SYS_LOCALBASE=\"${SYS_LOCALBASE}\"" >> "$insc"
	echo "cd \"\$PBI_PROGDIRPATH\"" >> "$insc"

	# Add the binary wrapper sym-links
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}/${PBI_INS_PATHSCRIPT}" ] ; then
		echo 'if [ `id -u` = "0" ] ; then ' >>${insc}
		echo "	$PBI_PROGDIRPATH/${PBI_FAKEBIN_DIR}/${PBI_INS_PATHSCRIPT}" >>${insc}
		echo "fi" >>${insc}
	fi

	# Look for any XDG scripts
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_APPMIME_DIR}/${PBI_INS_MIMESCRIPT}" ] ; then
		echo "$PBI_PROGDIRPATH/${PBI_APPMIME_DIR}/${PBI_INS_MIMESCRIPT}" >>${insc}
	fi
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_APPMENU_DIR}/${PBI_INS_MENUSCRIPT}" ] ; then
		echo "$PBI_PROGDIRPATH/${PBI_APPMENU_DIR}/${PBI_INS_MENUSCRIPT}" >>${insc}
	fi

	chmod 755 "${insc}"
	
}

# Create the deinstall script for the PBI
mk_deinstall_script() {
	echo "Creating deinstall script..."
	uisc="${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}/.pbi-uninstall.sh"

	echo "#!/bin/sh" > "$uisc"
	echo "PBI_PROGDIRPATH=\"${PBI_PROGDIRPATH}\"" >> "$uisc"
	echo "SYS_LOCALBASE=\"${SYS_LOCALBASE}\"" >> "$uisc"

	# Remove the binary wrapper sym-links
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_FAKEBIN_DIR}/${PBI_UNINS_PATHSCRIPT}" ] ; then
		echo 'if [ `id -u` = "0" ] ; then ' >>${uisc}
		echo "	$PBI_PROGDIRPATH/${PBI_FAKEBIN_DIR}/${PBI_UNINS_PATHSCRIPT}" >>${uisc}
		echo "fi" >>${uisc}
	fi

	# Look for any XDG scripts
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_APPMIME_DIR}/${PBI_UNINS_MIMESCRIPT}" ] ; then
		echo "$PBI_PROGDIRPATH/${PBI_APPMIME_DIR}/${PBI_UNINS_MIMESCRIPT}" >>${uisc}
	fi
        if [ -e "${PBI_STAGEDIRMNT}/${PBI_APPMENU_DIR}/${PBI_UNINS_MENUSCRIPT}" ] ; then
		echo "$PBI_PROGDIRPATH/${PBI_APPMENU_DIR}/${PBI_UNINS_MENUSCRIPT}" >>${uisc}
	fi
	chmod 755 "${uisc}"
}

# Create a dir for manipulating header info
mk_header_dir() {
	PBI_HEADERDIR="${PBI_STAGEDIRMNT}/pbimeta"
	if [ -e "${PBI_HEADERDIR}" ] ; then rm -rf "${PBI_HEADERDIR}" ; fi
	mkdir -p ${PBI_HEADERDIR}
}

# Create a dir for staging the final archive
mk_stage_dir() {
	if [ -n "$1" ] ; then
		cpDir="$1"
	else
		cpDir="${PBI_PROGDIRPATH}"
	fi

	PBI_STAGEDIR="${PBI_PROGDIRPATH}/.stagedir"
	echo "Creating Stage Dir: ${PBI_STAGEDIR}"
	if [ -e "${PBI_STAGEDIR}" ] ; then 
		rm -rf "${PBI_STAGEDIR}" 2>/dev/null
		chflags -R noschg ${PBI_STAGEDIR} 2>/dev/null
		rm -rf "${PBI_STAGEDIR}" 2>/dev/null
	fi
	mkdir -p ${PBI_STAGEDIR}

	mkdir -p ${PBI_STAGEDIR}/local
	mkdir -p ${PBI_STAGEDIR}/etc
	mkdir -p ${PBI_STAGEDIR}/rc.d
	mkdir -p ${PBI_STAGEDIR}/pbimeta
	mkdir -p ${PBI_STAGEDIR}/virtbase
	mkdir -p ${PBI_STAGEDIR}/linux
	mkdir -p ${PBI_STAGEDIR}/run

	# If we built with a module / conf directory, lets include it
	if [ -d "${PBI_CONFDIR}" ] ; then cp -r ${PBI_CONFDIR} ${PBI_STAGEDIR}/pbiconf; fi

	local _excOpts=""

	# Build module list of excludes
	if [ -n "$PBI_EXCLUDELIST" ] ; then
		for excl in $PBI_EXCLUDELIST
		do
			if [ -z "$_excOpts" ] ; then
				_excOpts="--exclude ${excl}"
			else
				_excOpts="$_excOpts --exclude ${excl}"
			fi
		done
	fi

	if [ "$2" = "move" ] ; then
		rmdir ${PBI_STAGEDIR}/local
		mv ${cpDir} ${PBI_STAGEDIR}/local
		ln -s ${PBI_STAGEDIR}/local /usr/local
	else
		# Now copy the stagedir
		tar cf - ${_excOpts} --exclude .stagedir \
		--exclude .pkgdb --exclude .ld-elf.hints --exclude make.conf \
		--exclude make.conf.bak --exclude .keepports \
		-C "${cpDir}" . 2>/dev/null \
		| tar xpf - -C ${PBI_STAGEDIR}/local 2>/dev/null
	fi

	cd ${PBI_PROGDIRPATH}
	PBI_STAGEDIRMNT="${PBI_STAGEDIR}"
	PBI_STAGEDIR="${PBI_STAGEDIR}/local"
}

# Remove the stagedir
rm_stage_dir() {
	# If this is in the chroot we can exit and let the parent cleanup
	if [ "$0" = "pbi_makeport_chroot" ] ; then return; fi

	cd /
	PBI_STAGEDIR="${PBI_PROGDIRPATH}/.stagedir"
	if [ -e "${PBI_STAGEDIR}" ] ; then 
		rm -rf "${PBI_STAGEDIR}" 2>/dev/null
		chflags -R noschg ${PBI_STAGEDIR} 2>/dev/null
		rm -rf "${PBI_STAGEDIR}" 2>/dev/null
	fi
}

# See if we need to clean the icons dir
clean_icons_dir() {
	if [ "${PBI_USESYSFONTS}" != "NO" ] ; then
		rm -rf ${PBI_STAGEDIR}/share/icons >/dev/null 2>/dev/null
		mkdir ${PBI_STAGEDIR}/share/icons >/dev/null 2>/dev/null
	fi
}

# See if we need to clean the stagedir
clean_stage_dir() {

	if [ "${PBI_USESYSGL}" != "NO" ] ; then
		rm ${PBI_STAGEDIR}/lib/libGl.* >/dev/null 2>/dev/null
		rm ${PBI_STAGEDIR}/lib/libGL.* >/dev/null 2>/dev/null
		rm ${PBI_STAGEDIR}/lib/libGLU.* >/dev/null 2>/dev/null
	fi
	if [ "${PBI_USESYSFONTS}" != "NO" ] ; then
		rm -rf ${PBI_STAGEDIR}/etc/fonts/* >/dev/null 2>/dev/null
		rm -rf ${PBI_STAGEDIR}/lib/X11/fonts/* >/dev/null 2>/dev/null
		rm -rf ${PBI_STAGEDIR}/lib/X11/icons/* >/dev/null 2>/dev/null
	fi
	if [ -e "${PBI_STAGEDIR}/lib/X11" ] ; then
		mkdir -p ${PBI_STAGEDIR}/lib/X11/icons/ >/dev/null 2>/dev/null
		mkdir -p ${PBI_STAGEDIR}/lib/X11/fonts/ >/dev/null 2>/dev/null
		mkdir -p ${PBI_STAGEDIR}/etc/fonts/ >/dev/null 2>/dev/null
	fi
}

# Copy over any resource files into the PBI dir
copy_resource_dir() {
	if [ -d "${PBI_CONFDIR}/${PBI_RESOURCE_DIR}" ] ; then
		echo "Copying ${PBI_CONFDIR}/${PBI_RESOURCE_DIR} -> ${PBI_STAGEDIR}"
		tar cf - -C ${PBI_CONFDIR}/${PBI_RESOURCE_DIR} --exclude .svn . 2>/dev/null \
		| tar xpf - -C ${PBI_STAGEDIR} 2>/dev/null
	fi
}

# Check if tar supports lzma compression
test_tar_lzma() {
	touch /tmp/.pbilzma.$$ >/dev/null 2>/dev/null
	tar cJf /tmp/.pbilzma.tar.$$ /tmp/.pbilzma.$$ >/dev/null 2>/dev/null
	_exitcode=$?
	rm /tmp/.pbilzma.$$ >/dev/null 2>/dev/null
	rm /tmp/.pbilzma.tar.$$ >/dev/null 2>/dev/null
	return $_exitcode
}

# Start creating the application archive 
mk_archive_file() {
        # Build module list of excludes
        if [ -n "$PBI_EXCLUDELIST" ] ; then
                for excl in $PBI_EXCLUDELIST
                do
                        if [ -z "$_excOpts" ] ; then
                                _excOpts="--exclude ${excl}"
                        else
                                _excOpts="$_excOpts --exclude ${excl}"
                        fi
                done
        fi
	PBI_CREATE_ARCHIVE="${PBI_CREATE_OUTDIR}/.PBI.$$.tbz"
	if test_tar_lzma ; then _tcmp="J" ; else _tcmp="j" ; fi
	echo "Creating compressed archive..."
	tar c${_tcmp}f "${PBI_CREATE_ARCHIVE}" ${_excOpts} -C ${PBI_STAGEDIRMNT} . 2>/dev/null
}

# Start creating the header archive
mk_header_file() {
	PBI_HEADER_ARCHIVE="${PBI_CREATE_OUTDIR}/.PBI-header.$$.tbz"
	tar cjf ${PBI_HEADER_ARCHIVE} -C ${PBI_HEADERDIR} . >/dev/null 2>/dev/null
}

# Start copying pbi details into header file
save_pbi_details_to_header() {
	local _osArch="$ARCH"
	local _osRel="$FBSDREL"
	if [ -n "${PBI_OSREL}" ] ; then
		_osRel="${PBI_OSREL}"
	fi

	if [ "${PBI_CREATEONLY}" = "YES" ] ; then
		_pbilow="`echo ${PBI_PROGNAME} | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
		echo "${PBI_APPDIR}/${_pbilow}-${_osArch}" > "${PBI_HEADERDIR}/pbi_defaultpath"
	else	
		echo "${PBI_PROGDIRPATH}" > "${PBI_HEADERDIR}/pbi_defaultpath"
	fi
	echo "${PBI_PROGNAME}" > "${PBI_HEADERDIR}/pbi_name"
	echo "${PBI_PROGVERSION}" > "${PBI_HEADERDIR}/pbi_version"
	echo "${PBI_PROGAUTHOR}" > "${PBI_HEADERDIR}/pbi_author"
	echo "${PBI_PROGWEB}" > "${PBI_HEADERDIR}/pbi_web"
	date "+%Y%m%d %H%M%S" > "${PBI_HEADERDIR}/pbi_mdate"

	if [ "${PBI_REQUIRESROOT}" = "YES" ] ; then
		touch ${PBI_HEADERDIR}/pbi_requiresroot
	fi

	# Do we have a license to accept?
	if [ -e "${PBI_CONFDIR}/${PBI_LICENSEFILE}" ] ; then
		cp "${PBI_CONFDIR}/${PBI_LICENSEFILE}" "${PBI_HEADERDIR}/${PBI_LICENSEFILE}"
	fi

	# Do we have a conf-supplied meta-file to copy?
	if [ -e "${PBI_CONFDIR}/${PBI_USERMETAFILE}" ] ; then
		cp "${PBI_CONFDIR}/${PBI_USERMETAFILE}" "${PBI_HEADERDIR}/${PBI_USERMETAFILE}"
	fi
	# Do we have a user-supplied meta-file to copy?
	if [ -n "$PBI_CREATE_USERMETA" ] ; then
		cp "$PBI_CREATE_USERMETA" "${PBI_HEADERDIR}/${PBI_USERMETAFILE}"
	fi

	# Check for additional meta-data
	if [ -n "$PBI_LICENSE" ] ; then
		echo "$PBI_LICENSE" > ${PBI_HEADERDIR}/pbi_license
	fi
	if [ -n "$PBI_TAGS" ] ; then
		echo "$PBI_TAGS" > ${PBI_HEADERDIR}/pbi_tags
	fi
	if [ -n "$PBI_PROGTYPE" ] ; then
		echo "$PBI_PROGTYPE" > ${PBI_HEADERDIR}/pbi_type
	fi
	if [ -n "$PBI_CATEGORY" ] ; then
		echo "$PBI_CATEGORY" > ${PBI_HEADERDIR}/pbi_category
	fi
	if [ -n "$PBI_ICONURL" ] ; then
		echo "$PBI_ICONURL" > ${PBI_HEADERDIR}/pbi_iconurl
	fi
	if [ -n "$PBI_DESC" ] ; then
		echo "$PBI_DESC" > ${PBI_HEADERDIR}/pbi_desc
	fi
	if [ -n "$PBI_SHORTDESC" ] ; then
		echo "$PBI_SHORTDESC" > ${PBI_HEADERDIR}/pbi_shortdesc
	fi
	if [ -n "$PBI_MAINTAINER" ] ; then
		echo "$PBI_MAINTAINER" > ${PBI_HEADERDIR}/pbi_maintainer
	fi

	# Custom install / remove scripts
	if [ -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_PREINS}" ] ; then
		cp "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_PREINS}" \
			"${PBI_HEADERDIR}/${MOD_PREINS}"
	else
		echo "#!/bin/sh" > ${PBI_HEADERDIR}/${MOD_PREINS}
	fi
	if [ -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_POSTINS}" ] ; then
		cp "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_POSTINS}" \
			"${PBI_HEADERDIR}/${MOD_POSTINS}"
	else
		echo "#!/bin/sh" > ${PBI_HEADERDIR}/${MOD_POSTINS}
	fi
	if [ -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_PREREM}" ] ; then
		cp "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/${MOD_PREREM}" \
			"${PBI_HEADERDIR}/${MOD_PREREM}"
	else
		echo "#!/bin/sh" > ${PBI_HEADERDIR}/${MOD_PREREM}
	fi

	# Copy over our icon
	if [ -n "${PBI_PROGICON}" -a -e "${PBI_STAGEDIR}/${PBI_PROGICON}" ] ; then
		# Get the file extension
		_iconExt=`echo "$PBI_PROGICON" | awk -F . '{print $NF}'`
		cp "${PBI_STAGEDIR}/${PBI_PROGICON}" "${PBI_HEADERDIR}/pbi_icon.${_iconExt}" >/dev/null 2>/dev/null
	else
		_iconExt=`echo "$PBI_DEFAULT_ICON_CHROOT" | awk -F . '{print $NF}'`
		cp "${PBI_DEFAULT_ICON_CHROOT}" "${PBI_HEADERDIR}/pbi_icon.${_iconExt}" >/dev/null 2>/dev/null
	fi

	# Check for any gui images
	if [ -e "${PBI_STAGEDIR}/${PBI_GUITOPBANNER}" ] ; then
		cp "${PBI_STAGEDIR}/${PBI_GUITOPBANNER}" "${PBI_HEADERDIR}/top-banner.png"
	fi
	if [ -e "${PBI_STAGEDIR}/${PBI_GUISIDEBANNER}" ] ; then
		cp "${PBI_STAGEDIR}/${PBI_GUISIDEBANNER}" "${PBI_HEADERDIR}/side-banner.png"
	fi

	# Save the uname details
	echo "${_osArch}" > "${PBI_HEADERDIR}/pbi_arch"
	echo "${_osRel}" > "${PBI_HEADERDIR}/pbi_fbsdver"
	echo "${PROGVERSION}" > "${PBI_HEADERDIR}/pbi_createver"

	# Get the total number of files in the STAGEDIR
	get_filetotal_dir "${PBI_STAGEDIR}"
	echo "${FILETOTAL}" > "${PBI_HEADERDIR}/pbi_archivecount"

	# Save a checksum of archive file
	sha256 -q "${PBI_CREATE_ARCHIVE}" > "${PBI_HEADERDIR}/pbi_archivesum"

	sign_pbi_files "$PBI_HEADERDIR"
}

# Use openssl to sign parts of the pbi header structure and archive 
sign_pbi_files() {
	if [ -z "${PBI_SSLPRIVKEY}" ] ; then return 0 ; fi
	_sf="${1}/pbi_archivesum ${1}/${MOD_PREINS} ${1}/${MOD_POSTINS} ${1}/${MOD_PREREM}"
	for i in $_sf
	do
		openssl dgst -sha1 \
  			-sign ${PBI_SSLPRIVKEY} \
  			-out ${i}.sha1 \
  			${i} >/dev/null 2>/dev/null
	done
}

# All the pieces are ready, spit out the final PBI file
mk_output_pbi() {
        if [ -n "${PBI_PROGICON}" -a -e "${PBI_STAGEDIR}/${PBI_PROGICON}" ] ; then
                icon="${PBI_STAGEDIR}/${PBI_PROGICON}"
        else
                icon="${PBI_DEFAULT_ICON_CHROOT}"
        fi

	# Set PBI name all lower-case
	_pbilow="`echo ${PBI_PROGNAME} | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
	outfile="${PBI_CREATE_OUTDIR}/${_pbilow}-${PBI_PROGVERSION}-${ARCH}.pbi"

	mark1="${PBI_CREATE_OUTDIR}/.pbimark1.$$"
	mark2="${PBI_CREATE_OUTDIR}/.pbimark2.$$"
	echo "
${PBI_SS_ICON}" >$mark1
	echo "
${PBI_SS_ARCHIVE}" >$mark2


	# DO IT, DO IT NOW!!!
	cat ${PBI_HEADER_ARCHIVE} $mark1 ${icon} $mark2 ${PBI_CREATE_ARCHIVE} > ${outfile}
	sha256 -q ${outfile} > ${outfile}.sha256

	echo "Created PBI: ${outfile}"

	rm $mark1
	rm $mark2
	rm ${PBI_HEADER_ARCHIVE}
	rm ${PBI_CREATE_ARCHIVE}
}

get_filetotal_dir() {
	FILETOTAL="`find ${1} | wc -l | tr -d ' '`"
}

pbi_delete_init() {
  	require_root_or_group
	init_tmpdir
	parse_delete_pbi_cmdline "$@"
	do_pbi_delete
}

# Delete this PBI
do_pbi_delete() {
	load_info_from_dir "${PBI_DBAPPDIR}/${PBI_DELETENAME}"
	PBI_PROGDIRPATH="${PBI_ORIGPROGDIRPATH}"

	get_username_from_file "${PBI_DBAPPDIR}/${PBI_DELETENAME}/pbi_name"
	if [ "$FILEUSER" != `whoami` -a `id -u` != "0" ] ; then
		exit_err "Permission denied to modify PBI installed by: $FILEUSER"
	fi

	# Set the dirty flag that we are removing this PBI
	touch ${PBI_DBAPPDIR}/${PBI_DELETENAME}/.pbiDeleted

	# Unmount the PBI if its mounted
	/usr/pbi/.pbime umount "/usr/pbi/.mounts/`basename $PBI_PROGDIRPATH`"

	# Sleep 5 before nuking dirs
	sleep 5

	check_preremove_script
	run_remove_script
 	remove_pbidir
	unregister_pbi
	
}

# Run the removal script for this PBI
run_remove_script() {
	uisc="${PBI_PROGDIRPATH}/${PBI_FAKEBIN_DIR}/.pbi-uninstall.sh"
	if [ ! -e "$uisc" ] ; then return 0 ; fi

	# If not running as root, be sure to cleanup path links
	if [ "`id -u`" != "0" ]; then
	 	cat ${PBI_PROGDIRPATH}/${PBI_FAKEBIN_DIR}/${PBI_UNINS_PATHSCRIPT} | grep 'rm "$SYS_LOCALBASE/bin' | sed 's|$SYS_LOCALBASE|${HOME}|g' >${PBI_TMPDIR}/.binlnks
         	while read lnk
          	do
               	 	/bin/sh -c "${lnk}"
          	done <${PBI_TMPDIR}/.binlnks
          	rm ${PBI_TMPDIR}/.binlnks
        fi
        export_script_vars
	if [ "$PBI_VERBOSE" = "YES" ] ; then
       		sh "${uisc}"
	else
       		sh "${uisc}" >/dev/null 2>/dev/null
	fi
}

# Function to check the supplied $1 dir for any mounts before we
# do a rm -rf
umount_before_rm()
{
   	if [ -z "${1}" ] ; then return 0 ; fi

        local _ddir="$1"
        echo "$_ddir" | rev | grep -q '^/'	
	if [ $? -ne 0 ] ; then
	   _ddir="${_ddir}/"
	fi
	
	mount | grep -q "on ${_ddir}"
	if [ $? -ne 0 ] ; then return 0; fi

        for i in `mount | grep "on ${_ddir}" | awk '{print $3}'`
	do
	   umount -f ${i} >/dev/null 2>/dev/null
	   if [ $? -ne 0 ] ; then 
		exit_err "Could not umount ${i} before rm -rf, bailing!"
	   fi
	done
	return 0
}

# Remove the pbi directory
remove_pbidir() {
	if [ -z "${PBI_PROGDIRPATH}" ] ; then return 0 ; fi
	if [ ! -d "${PBI_PROGDIRPATH}" ] ; then return 0 ; fi
	if [ "${PBI_PROGDIRPATH}" = "/" ] ; then return 0 ; fi
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Removing: ${PBI_PROGDIRPATH}"
	fi

        # Make sure we are unmounted
        umount_before_rm "${PBI_PROGDIRPATH}"
	
	rm -rf "${PBI_PROGDIRPATH}" >/dev/null 2>/dev/null

	# Do we have leftovers?
	if [ -d "${PBI_PROGDIRPATH}" ] ; then
		chflags -R noschg "${PBI_PROGDIRPATH}" >/dev/null 2>/dev/null
		chmod -R 777 "${PBI_PROGDIRPATH}" >/dev/null 2>/dev/null
		rm -rf "${PBI_PROGDIRPATH}" >/dev/null 2>/dev/null
	fi
}

# Remove this PBI registration
unregister_pbi() {
	if [ -z "${PBI_DBAPPDIR}" ] ; then return 0 ; fi
	if [ -z "${PBI_DELETENAME}" ] ; then return 0 ; fi
	if [ ! -d "${PBI_DBAPPDIR}/${PBI_DELETENAME}" ] ; then return 0 ; fi
	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Removing: ${PBI_DBAPPDIR}/${PBI_DELETENAME}"
	fi
	rm -rf "${PBI_DBAPPDIR}/${PBI_DELETENAME}"

}

# Check if we have a preinstall script we need to use
check_preremove_script() {
	if [ ! -e "${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}" ] ; then return 0 ; fi

	if [ "$PBI_VERBOSE" = "YES" ] ; then
		echo "Running pre-removal script: ${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}"
	fi
        export_script_vars
       	sh "${PBI_DBAPPDIR}/${PBI_DELETENAME}/${MOD_PREREM}"
}

add_app_path_links()
{
	# If root, run the regular path script
	if [ `id -u` = "0" ] ; then
		sh "${1}/${PBI_FAKEBIN_DIR}/${PBI_INS_PATHSCRIPT}" >/dev/null 2>/dev/null
		return
	fi

	# Running as user add to ~/bin
	init_tmpdir
	if [ ! -d "${HOME}/bin" ] ; then mkdir -p "${HOME}/bin"; fi
	cat ${1}/${PBI_FAKEBIN_DIR}/${PBI_INS_PATHSCRIPT} | grep "${1}/${PBI_FAKEBIN_DIR}" | grep '$PBI_BINDIR' | sed 's|$PBI_BINDIR|${HOME}/bin|g' >${PBI_TMPDIR}/.binlnks
	while read lnk
	do
		/bin/sh -c "${lnk}"
		
	done <${PBI_TMPDIR}/.binlnks
	rm ${PBI_TMPDIR}/.binlnks
	
}

del_app_path_links()
{
	# If root, run the regular path script
	if [ `id -u` = "0" ] ; then
		sh "${1}/${PBI_FAKEBIN_DIR}/${PBI_UNINS_PATHSCRIPT}" >/dev/null 2>/dev/null
		return
	fi

	# Running as user remove from ~/bin
	if [ ! -d "${HOME}/bin" ] ; then mkdir -p "${HOME}/bin"; fi
	for lnk in `ls ${1}/${PBI_FAKEBIN_DIR}`
	do
		if [ "$lnk" = "$PBI_INS_PATHSCRIPT" -o "$lnk" = "$PBI_UNINS_PATHSCRIPT" ]
		then
			continue
		fi

		if [ ! -e "${HOME}/bin/$lnk" ] ; then continue ; fi
		if [ ! -h "${HOME}/bin/$lnk" ] ; then continue ; fi
			
		ls -al "${HOME}/bin/$lnk" | awk '{print $11}' | grep $1 >/dev/null 2>/dev/null
		if [ "$?" = "0" ] ; then
			rm ${HOME}/bin/$lnk
		fi
	done
	
}

is_pbi_installed() {
	
	# Check if the container version is loaded
	for lPBI in `ls ${PBI_DBAPPDIR}/ 2>/dev/null`
	do
		if [ ! -e "${PBI_DBAPPDIR}/${lPBI}/pbi_name" ] ; then
			continue
		fi
		_tLow="`cat $lPBI/pbi_name | tr '[:upper:]' '[:lower:]' | sed 's| ||g'`"
		if [ "$_tLow" = "$PBI_PROGNAME" ] ; then 
			PBI_CONTAINER="YES"
			return 0
		fi
	done

	# Now check for pkgng version
	pkg-static query '%n' $1 >/dev/null 2>/dev/null
	if [ $? -eq 0 ] ; then return 0; fi

	return 1
}

pbi_icon_init() {
	parse_icon_pbi_cmdline "$@"
	
	do_pbi_icon
}

# Start the PBI icon process
do_pbi_icon() {

	if [ "$PBI_CONTAINER" = "YES" ] ; then
           	PBI_EXEDIR="$PBI_PROGDIRPATH/$PBI_FAKEBIN_DIR/"
		PBI_LAPPDIR="${PBI_PROGDIRPATH}/local/"
	else
           	PBI_EXEDIR=""
		PBI_LAPPDIR="/usr/local/"
	fi

	# Only need to do path links when working with containers
	if [ "${PBI_PATHADD}" = "YES" -a "$PBI_CONTAINER" = "YES" ] ; then
		add_app_path_links "$_appDir"
	fi
	if [ "${PBI_PATHDEL}" = "YES" -a "$PBI_CONTAINER" = "YES" ] ; then
		del_app_path_links "$_appDir"
	fi

	# Add desktop / menu icons
	if [ "${PBI_DESKADD}" = "YES" ] ; then
		require_root_or_group
		add_xdg_icon "$PBI_ORIGIN" "desktop"
	fi
	if [ "${PBI_DESKDEL}" = "YES" ] ; then
		require_root_or_group
		del_xdg_icon "$PBI_ORIGIN" "desktop"
	fi
	if [ "${PBI_MENUADD}" = "YES" ] ; then
		require_root_or_group
		add_xdg_icon "$PBI_ORIGIN" "menu"
	fi
	if [ "${PBI_MENUDEL}" = "YES" ] ; then
		require_root_or_group
		del_xdg_icon "$PBI_ORIGIN" "menu"
	fi

	# Add mime types
	if [ "${PBI_MIMEADD}" = "YES" ] ; then
		require_root_or_group
		add_xdg_icon "$PBI_ORIGIN" "mime"
	fi
	if [ "${PBI_MIMEDEL}" = "YES" ] ; then
		require_root_or_group
		del_xdg_icon "$PBI_ORIGIN" "mime"
	fi

	exit_trap
}

del_xdg_icon() {

	local type="$2"
	case $type in
		desktop) subdir="xdg-desktop" 
			 cmd="xdg-desktop-icon"
			 ext="desktop"
			 ;;
		   menu) subdir="xdg-menu" 
			 cmd="xdg-desktop-menu"
			 ext="desktop"
			 ;;
		   mime) subdir="xdg-mime" 
			 cmd="xdg-mime"
			 ext="xml"
			 ;;
		      *) exit_err "Invalid xdg_icon()" ;;

	esac

	# Look for any .desktop files to remove
	for i in `ls ${PBI_DBINDEXDIR}/$1/$subdir/*.${ext} 2>/dev/null`
	do
		$cmd uninstall `basename $i`
	done
}

add_xdg_icon() {
	init_tmpdir

	local type="$2"
	case $type in
		desktop) subdir="xdg-desktop" 
			 cmd="xdg-desktop-icon"
			 ext="desktop"
			 ;;
		   menu) subdir="xdg-menu" 
			 cmd="xdg-desktop-menu"
			 ext="desktop"
			 ;;
		   mime) subdir="xdg-mime" 
			 cmd="xdg-mime"
			 ext="xml"
			 ;;
		      *) exit_err "Invalid xdg_icon()" ;;
	esac

	# See if we have any .desktop files to install
	for i in `ls ${PBI_DBINDEXDIR}/${1}/${subdir}/*.${ext} 2>/dev/null`
	do
		fNam=`basename $i`
		# Copy over the .desktop file, modifying any variables within
	        cat "${i}" \
           	| sed "s|%%PBI_EXEDIR%%/|${PBI_EXEDIR}|g" \
           	| sed "s|%%PBI_EXEDIR%%|${PBI_EXEDIR}|g" \
		| sed "s|%%PBI_APPDIR%%/|${PBI_LAPPDIR}|g" \
		| sed "s|%%PBI_APPDIR%%|${PBI_LAPPDIR}|g" \
		> "${PBI_TMPDIR}/${fNam}"

		# Fix icons
		check_xdg_icon "${PBI_TMPDIR}/${fNam}" "$1"

		# Set the correct permissions on the desktop file
		chmod 744 "${PBI_TMPDIR}/${fNam}"

		# Install the icon now
		$cmd install --novendor ${PBI_TMPDIR}/$fNam

		# Cleanup
		rm ${PBI_TMPDIR}/$fNam
	done

}

# 1 - .desktop file to check
# 2 - PBI_ORIGIN
check_xdg_icon() {
	local iPath=`grep "^Icon=" ${1} | sed 's|^Icon=||g'`
	local oPath="${iPath}"
	# Do we have an icon in this file?
	if [ -z "$iPath" ] ; then return ; fi
	# Does the icon exist?
	if [ -e "$iPath" ] ; then return ; fi

	# No icon? Lets check for one in the resources dir and setup
	if [ "$PBI_CONTAINER" = "YES" ] ; then
		iPath=`echo $iPath | sed "s|${PBI_PROGDIRPATH}/local/||g"`
	else
		iPath=`echo $iPath | sed "s|/usr/local/||g"`
	fi
	
	# Do we have an icon in resources?
	if [ ! -e "${PBI_DBINDEXDIR}/$2/resources/${iPath}" ] ; then
		return
	fi

	# Copy the icon file
	local iFile=`basename $iPath`
	cp "${PBI_DBINDEXDIR}/$2/resources/${iPath}" ${PBI_XDGICONDIR}/${iFile}

	# Update the location in the XDG file
	sed -i '' "s|^Icon=$oPath|Icon=${PBI_XDGICONDIR}/${iFile}|g" ${1}
}

pbid_init() {
	require_root

	parse_pbid_cmdline "$@"

	do_pbid
}

# This is a crude hack, but we need to copy libGL* to a location outside
# of /usr/local for PBIs to be able to access them
check_populate_opengl()
{
  local lG
  for i in `ls /usr/local/lib/libGl.* /usr/local/lib/libGL.* /usr/local/lib/libGLU.* /usr/local/lib/libnvidia-* 2>/dev/null`
  do
    lG=`basename $i`
    cp ${i} /usr/lib/${lG}
  done
}

# Start the PBID daemon
do_pbid() {

	# Start by sourcing /etc/profile
	# This grabs any HTTP_ / FTP_ PROXY variables
	. /etc/profile

	# Allow user supplied logfile
        if [ -z "${PBID_LOGFILE}" ] ; then
	  _pbid_log="/var/log/pbid.log"
	else
          _pbid_log="${PBID_LOGFILE}"
        fi

	# Set verbosity 
	_redir="&1"
	if [ "${PBI_VERBOSE}" != "YES" ] ; then _redir="/dev/null" ; fi
	echo "Started pbid: `date`" > ${_pbid_log}

	# Check for opengl libs to link
	check_populate_opengl

	while
	i=1
	do
		# Do regular sleeps
		qslp=0

		# Check if we have any out of date index files to update
		check_update_index "${_iMd5}"
		if [ $? -eq 1 ] ; then qslp=1; fi

		# Check if we should rotate the logfile
		_pbidLines=`wc -l ${_pbid_log} | awk '{ print $1 }'`
		if [ $(is_num "$_pbidLines") ] ; then
			if [ $_pbidLines -gt $PBI_LOG_LINES ] ; then
				echo "Logfile turnover: `date`" >${_pbid_log}
			fi
		fi
		

		# Done with our check, lets go back to sleep now
		if [ $qslp -eq 1 ] ; then
			sleep 10
		else
			sleep ${PBIDSLEEP}
		fi
	done

}

pbi_info_init() {
	parse_info_pbi_cmdline "$@"
	
	do_pbi_info
}

# Display information on the PBI / PBIs
do_pbi_info() {

	# If we are listing available PBIs via the index file
	if [ "$PBI_INFOINDEX" = "YES" ] ; then
		
		# List the available PBIs from the index
		do_index_listing
		
		exit_trap
	fi

	if [ "$PBI_INFONAME" = "--ALL--" ] ; then
		# List PBI containers First
		for i in `ls ${PBI_DBAPPDIR}/ 2>/dev/null`
		do
			echo "PBIs installed into containers"
			echo "-------------------------------"
			if [ -e "${PBI_DBAPPDIR}/${i}/pbi_name" ] ; then
				if [ "$PBI_VERBOSE" = "YES" ] ; then
					PBI_CONTAINER="YES"
        				load_info_from_dir "${PBI_DBAPPDIR}/${i}"
					get_username_from_file "${PBI_DBAPPDIR}/${i}"
					PBI_INSTALLED_BY=$FILEUSER
					pbi_display_info
					pbi_display_gui "${PBI_DBAPPDIR}/${i}" ""
					echo " "
				else
					echo "${i}"
				fi
			fi
		done

		# No Database? Ain't gona find much..
		if [ ! -e "$PBI_INDEXDB" ] ; then return; fi

		# Next list package PBIs
		echo "PBIs installed into system"
		echo "-------------------------------"
		for pkgori in `pkg query '%o'`
		do
			line=`grep "^PBI=${pkgori}::::" $PBI_INDEXDB`
			if [ -z "$line" ] ; then continue ; fi

			PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
			PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
			PBI_PROGVERSION=`pkg-static query '%v' $pkgori`
			if [ "$PBI_VERBOSE" = "YES" ] ; then
				PBI_PKGOTHER=`echo $line | awk -F:::: '{print $3}'`
				PBI_PROGAUTHOR=`echo $line | awk -F:::: '{print $4}'`
				PBI_PROGWEB=`echo $line | awk -F:::: '{print $5}'`
				PBI_PROGLICENSE=`echo $line | awk -F:::: '{print $6}'`
				PBI_PROGTYPE=`echo $line | awk -F:::: '{print $7}'`
				PBI_PROGCAT=`echo $line | awk -F:::: '{print $8}'`
				PBI_PROGMAINT=`echo $line | awk -F:::: '{print $10}'`
				PBI_SHORTDESC=`echo $line | awk -F:::: '{print $11}'`
				PBI_APPARCH=`uname -m`
				PBI_CONTAINER="NO"
				pbi_display_info
			else
				echo "${PBI_PROGNAME}-${PBI_PROGVERSION}"
			fi

		done
		
	else
		# Start loading our variables
        	load_info_from_dir "${PBI_DBAPPDIR}/${PBI_INFONAME}"
		get_username_from_file "${PBI_DBAPPDIR}/${PBI_INFONAME}"
		PBI_INSTALLED_BY=$FILEUSER
		pbi_display_info
	fi
}

# Read through the master index file and provide listing of available PBIs for installation
do_index_listing()
{
	# No Database? Ain't gona find much..
	if [ ! -e "$PBI_INDEXDB" ] ; then return; fi

	echo "Current and available PBIs. * = current"
	echo "Repository: $_rDesc"
	echo "----------------------------------------------------------------"

	while read line
	do
		echo $line | grep -q "^PBI="
		if [ $? -ne 0 ] ; then continue ; fi

		PBI_PROGNAME=`echo $line | awk -F:::: '{print $2}'`
		PBI_PROGNAME=`echo ${PBI_PROGNAME} | tr -d ' ' | tr '[A-Z]' '[a-z]'`
		PBI_ORIGIN=`echo $line | awk -F:::: '{print $1}' | sed 's|PBI=||g'`
		PBI_PROGVERSION=`pkg-static rquery '%v' $PBI_ORIGIN`
		echo "$PBI_PROGNAME-$PBI_PROGVERSION"
	done < $PBI_INDEXDB
}

# Function to pad a variable to X spaces
pad_var() {
	local _pVar="$1"
	local _pNum="$2"
	PAD_VAR="`echo \"$_pVar                                                                                    x\" | cut -c 1-$_pNum`"
}

# Checks if we have a custom script to run prior to port make
run_pbi_preportmake()
{
  	if [ ! -d "${PBI_CONFDIR}" ] ; then return 0 ; fi
  	if [ ! -d "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}" ] ; then return 0 ; fi
  	if [ ! -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/pre-portmake.sh" ] ; then return 0 ; fi

	export_script_vars

	sh "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/pre-portmake.sh"
	if [ "$?" != "0" ] ; then
		exit_err "pre-portmake.sh failed!"
	fi
}

# Checks if we have a custom script to run prior to port make
run_pbi_postportmake()
{
  	if [ ! -d "${PBI_CONFDIR}" ] ; then return 0 ; fi
  	if [ ! -d "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}" ] ; then return 0 ; fi
  	if [ ! -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/post-portmake.sh" ] ; then return 0 ; fi

	export_script_vars

	sh "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/post-portmake.sh"
	if [ "$?" != "0" ] ; then
		echo "Warning: post-portmake.sh returned non-0 status!"
	fi
}

# Checks if we have a custom script to run prior to pbi create
run_pbi_prepkgscript()
{
  	if [ ! -d "${PBI_CONFDIR}" ] ; then return 0 ; fi
  	if [ ! -d "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}" ] ; then return 0 ; fi
  	if [ ! -e "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/pre-pbicreate.sh" ] ; then return 0 ; fi

	export_script_vars

	sh "${PBI_CONFDIR}/${PBI_CONF_SCRIPTSDIR}/pre-pbicreate.sh"
	if [ "$?" != "0" ] ; then
		echo "Warning: post-portmake.sh returned non-0 status!"
	fi
}

# Begins the port make
start_pbi_makeport()
{
  	# Remove any trailing '/'
  	echo $PBI_MAKEPORT | grep -q "/$"
  	if [ $? -eq 0 ] ; then
     		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  	fi

	do_port_build "${PBI_MAKEPORT}"
}

# Prune any ports which aren't required for runtime
start_pbi_prune_ports()
{
	if [ "${PBI_PRUNEBUILDPORTS}" = "NO" ] ; then return ; fi

	get_pkgname "${PBI_MAKEPORT}"
	echo "${PKGNAME}" > /.keepports
	make -C "${PORTSDIR}/${PBI_MAKEPORT}" PORTSDIR=${PORTSDIR} package-depends | cut -d: -f1 >> /.keepports

	# Do the same for any OTHERPORTS
	for port in ${PBI_MKPORTBEFORE}
	do
                if [ ! -d "${PORTSDIR}/${port}" ] ; then continue ; fi
		get_pkgname "${port}"
		echo "${PKGNAME}" >> /.keepports
		make -C "${PORTSDIR}/${port}" PORTSDIR=${PORTSDIR} package-depends | cut -d: -f1 >> /.keepports
        done

	for port in ${PBI_MKPORTAFTER}
	do
                if [ ! -d "${PORTSDIR}/${port}" ] ; then continue ; fi
		get_pkgname "${port}"
		echo "${PKGNAME}" >> /.keepports
		make -C "${PORTSDIR}/${port}" PORTSDIR=${PORTSDIR} package-depends | cut -d: -f1 >> /.keepports
        done

	# Don't strip out pkgng
	pkg info pkg >> /.keepports
	
	# Sort and clean the ports
	cat /.keepports | sort | uniq > /.keepports.tmp
	mv /.keepports.tmp /.keepports

	# Now remove any unused ports
	for j in `pkg info -a | cut -d " " -f 1`
	do
		grep -q "^${j}" "/.keepports"
		if [ $? -ne 0 ] ; then 
			echo "Removing non-required port: ${j}"
			$PKG_DELETE ${j} 
		fi
	done
}

# Get the full package-name for a target port
get_pkgname() {
        name="`pkg info -O ${1} | awk '{print $1}'`"
	PKGNAME="${name}"
}

# Make any additional required ports 
start_pbi_mkportbefore()
{
	if [ -z "${PBI_MKPORTBEFORE}" ] ; then return ; fi
	
	for port in ${PBI_MKPORTBEFORE}
	do
  		# Cleanup $port
  		echo $port | grep -q "/$"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|/$||g'`"; fi
  		echo $port | grep -q "^/"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|^/||g'`"; fi

		if [ -n "$PBI_PKGNGBUILD" ] ; then
			pkg-static rquery '%v' ${port} >/dev/null 2>/dev/null
			if [ $? -ne 0 ] ; then
				exit_err "No package exists for: ${port}"
			fi
			do_port_build "${port}"
			continue
		fi

		if [ ! -d "/usr/ports/${port}" ] ; then
			exit_err "/usr/ports/${port} does not exist!"
		fi
		do_port_build "${port}"
	done

}

# Make any additional required ports 
start_pbi_mkportafter()
{
	if [ -z "${PBI_MKPORTAFTER}" ] ; then return ; fi
	
	for port in ${PBI_MKPORTAFTER}
	do
  		# Cleanup $port
  		echo $port | grep -q "/$"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|/$||g'`"; fi
  		echo $port | grep -q "^/"
  		if [ $? -eq 0 ] ; then port="`echo $port | sed 's|^/||g'`"; fi

		if [ -n "$PBI_PKGNGBUILD" ] ; then
			pkg-static rquery '%v' ${port} >/dev/null 2>/dev/null
			if [ $? -ne 0 ] ; then
				exit_err "No package exists for: ${port}"
			fi
			do_port_build "${port}"
			continue
		fi

		# Doing a regular port build
		if [ ! -d "/usr/ports/${port}" ] ; then
			exit_err "/usr/ports/${port} does not exist!"
		fi
		do_port_build "${port}"
	done

}

# Function which checks the digital signature of a PBI to match it to a particular repo
pbi_checksig_repomatch() {
  	if [ `id -u` != "0" ] ; then return ; fi

        # See which repo / key this PBI associates to, if any
	check_valid_sigs "${1}"
	if [ "$?" = "0" -a -n "$PBI_VALIDKEYSIG" ] ; then
		_rMd5="`echo ${PBI_VALIDKEYSIG} | cut -d '.' -f 1`"
		echo "$_rMd5" | sed "s|${PBI_DBKEYDIR}/||g" > ${1}/pbi_repo
	fi
}

# Check if we need to pull down the updated INDEX file
check_update_index() {

	init_tmpdir
	local _pbiIndexTime="${PBI_DBINDEXDIR}.time"
		
	# Check if its been greater than $PBI_INDEXREFRESH hours since the last update
	if [ -e "${_pbiIndexTime}" ] ; then
		_curTime=`date +%s`
		_oTime=`cat ${_pbiIndexTime}`
		_trigTime=`expr ${PBI_INDEXREFRESH} \* 60 \* 60`
		expr $_curTime - $_oTime >/dev/null 2>/dev/null
		if [ "$?" = "0" ] ; then
			_passed=`expr $_curTime - $_oTime`
			if [ "$_passed" -lt "$_trigTime" ] ; then
				return 0;
			fi
		fi
		
	fi
	
	cd $PBI_TMPDIR

	# Start refreshing indexes
	if [ "${PBI_VERBOSE}" = "YES" ] ; then
		echo "Updating PBI indexes"
		echo "Updating PBI indexes: `date`" >> ${_pbid_log}
	fi
	
	# Check the specified repo in repo/pkgng-repo file
	foundIndex=0
	local _pRepo="`cat ${PBI_SHARE_DIR}/pkgng-repo`"
	rm ${PBI_INDEXFILE} 2>/dev/null
	rm ${PBI_INDEXFILE}.sha1 2>/dev/null

	# Get the URL for this repo
	url=`cat ${_pRepo} | grep 'url:' | sed 's|url:||g' | awk '{print $1}' | sed 's|^"||g' | sed 's|",$||g'`

	# Fetch the index files if they exist
	fetch -o "${PBI_INDEXFILE}" "${url}/${PBI_INDEXFILE}" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then return 1; fi
	fetch -o "${PBI_INDEXFILE}.sha1" "${url}/${PBI_INDEXFILE}.sha1" >/dev/null 2>/dev/null
	if [ "$?" != "0" ] ; then return 1; fi

	# Got an index file, lets check signatures
	check_file_sig "${PBI_INDEXFILE}"
	if [ $? -ne 0 ] ; then 
		if [ "${PBI_VERBOSE}" = "YES" ] ; then
			echo "Failed verifying signature on PBI Index"
		fi
		echo "Failed verifying signature on PBI Index: `date`" >> ${_pbid_log}
		continue
	fi
	echo "Updating PBI index: `date`" >> ${_pbid_log}

	# Extract the INDEXFILE contents now
	if [ -d "${PBI_DBINDEXDIR}.new" ] ; then
		rm -rf ${PBI_DBINDEXDIR}.new
	fi
	mkdir ${PBI_DBINDEXDIR}.new
	tar xvf ${PBI_INDEXFILE} --no-same-owner -C "${PBI_DBINDEXDIR}.new" >/dev/null 2>/dev/null
	if [ $? -ne 0 ] ; then
		return 1
	fi

	# Move the new index into place
	if [ -e "${PBI_DBINDEXDIR}" ] ; then
	   mv ${PBI_DBINDEXDIR} ${PBI_DBINDEXDIR}.old
	   rm -rf ${PBI_DBINDEXDIR}.old &
	fi
	mv ${PBI_DBINDEXDIR}.new ${PBI_DBINDEXDIR}
		
	# Cleanup
	foundIndex=1
	rm ${PBI_INDEXFILE}
	rm ${PBI_INDEXFILE}.sha1
	
	echo "Finished updating index: `date`" >> ${_pbid_log}
	if [ "${PBI_VERBOSE}" = "YES" ] ; then
		echo "Finished updating index"
	fi

	if [ $foundIndex -eq 0 ] ; then return 1; fi

	# Save the time that we are done
	date +%s > ${_pbiIndexTime}

	return 0
}

is_num()
{
	expr $1 + 1 2>/dev/null
	return $?
}

# Function to check if the port is flagged to only build on specific arch
# Returns 0 for OK, 1 for invalid arch
check_port_compat_arch()
{
	local sPort=$1
        have32="false";
 	local cValues="`make -C $sPort -V ONLY_FOR_ARCHS PORTSDIR=${PORTSDIR}`"
	if [ -z "$cValues" ] ; then return 0 ; fi

	for cArch in $cValues
	do
		if [ "$cArch" = "$ARCH" ] ; then return 0; fi
                if [ "$cArch" = "i386" ] ; then have32="true" ; fi
	done
	return 1
}

# start processing autobuild
pbi_autob_init() {

        require_root

        parse_autob_pbi_cmdline "$@"

        do_pbi_autob
}

check_zfs_ab_destroy()
{
	local bNum=$1
 	if [ -e "${PBI_TMPDIR}/${bNum}.zmnt" ] ; then
 		zDir=`cat ${PBI_TMPDIR}/${bNum}.zmnt`
  		# Make sure this zfs dataset is in the PBI_APPDIR directory
 		echo $zDir | grep -q "${PBI_APPDIR}/" 
	    	if [ $? -eq 0 ] ; then
		  # Make sure all is unmounted
		  umount -f ${PBI_CHROOTDIR}/dev >/dev/null 2>/dev/null
		  umount -f ${PBI_CHROOTDIR}/compat/linux/proc >/dev/null 2>/dev/null
	  	  umount -f ${PBI_CHROOTDIR}/usr/ports >/dev/null 2>/dev/null
	 	  umount -f ${PBI_CHROOTDIR}/pkgs >/dev/null 2>/dev/null
		  umount -f ${PBI_CHROOTDIR}/.ccache >/dev/null 2>/dev/null
		  umount -f ${PBI_CHROOTDIR}/usr/wrkdirprefix >/dev/null 2>/dev/null
		  sleep 3
		  umount -f ${PBI_CHROOTDIR}/dev >/dev/null 2>/dev/null
		  sync
		  sleep 3
             	  zfs destroy -r "${zDir}"
       	 	  rmdir "${zDir}" >/dev/null 2>/dev/null
		fi
  	fi
}

ab_clean_build_tmpfiles()
{
	local build=$1

	# Cleanup 
	rm ${PBI_TMPDIR}/${build}.result 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.pid 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.bPort 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.od 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.mp 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.cd 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.pv 2>/dev/null
	rm ${PBI_TMPDIR}/${build}.zmnt 2>/dev/null
}

# Start the auto-build traversal process
do_pbi_autob() {

	echo "`basename ${0}` started: `date`"

	# Prune any outdir files which we don't have modules for
	do_pbi_autob_prune

	cd "${PBI_AB_CONFDIR}"
	init_tmpdir

	# Get this runs timestamp
	PBI_AB_TIMESTAMP=`date | md5`


	# Build our list of targets first
	echo "=> Creating build queue list..."
	ab_get_build_list

	done=0
	rebuildlist=0
	while :; do
	  activity=0
	  # Start checking each job
	  for build in ${JOBS-$(jot -w %02d ${PBI_AB_BUILDERS})}; do
		# Is this builder running?
		if [ -e "${PBI_TMPDIR}/${build}.pid" ] ; then
			if pgrep -qF "${PBI_TMPDIR}/${build}.pid" >/dev/null 2>&1; then 
				activity=1
				continue; 
			else
		 		# Do the ZFS destroy here if necessary
				check_zfs_ab_destroy "$build"
				
				# Run the post-build process
				ab_post_build ${build}

				# Cleanup
				ab_clean_build_tmpfiles ${build}
			fi
		fi
		if [ $done -eq 1 ] ; then continue ; fi

		# Builder idle, lets figure out the next build
  		#echo "==> Finding target for build process [$build]"
		start_next_ab_target "$build"
		if [ $? -eq 0 ] ; then 
			# Nothing left to build, lets wait for any existing build to finish before exiting
			done=1
		fi
		activity=1
          done

	  # Every 2 hours, we can re-scan the modules directory, catch any ones which may have been added / changed
	  if [ $rebuildlist -eq 7200 ] ; then
	     rebuildlist=0
	     ab_get_build_list
	  else
	     rebuildlist=`expr $rebuildlist + 1`
          fi

	  # Wait before checking again
          [ $activity -eq 1 ] && sleep 1
	  # Nothing to do? We can end now
          [ $activity -eq 0 ] && break
	done 

	echo "`basename ${0}` Finished: `date`"
};

ab_get_build_list()
{

   AB_FOUND="0"
   unset CUR_PRIORITY_PBI CUR_WORKING_PBI

   # Clear the tmp build list
   rm ${PBI_TMPDIR}/.ablist 2>/dev/null
		
   cd "${PBI_AB_CONFDIR}"
   for pbi in `find . -type f -name "${PBI_CONFFILE}" | grep -v '\.svn' | sort`
   do
	# Figure out the target port for this build
	unset PBI_MAKEPORT PBI_BUILDKEY PBI_PROGVERSION PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_AB_NOPKGBUILD

	. ${pbi}

	_cd=$(dirname $pbi | sed 's|./||')
	PBI_CONFDIR="$_cd"

	# Make sure PBI_MAKEPORT is set
	if [ -z "${PBI_MAKEPORT}" ] ; then
		PBI_MAKEPORT=`echo $pbi | sed 's|./||'`
		export PBI_MAKEPORT
	fi	

  	# Remove any trailing '/'
  	echo $PBI_MAKEPORT | grep -q "/$"
  	if [ $? -eq 0 ] ; then
     		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  	fi
	
	# Check for missing port target
	if [ -z "$PBI_MAKEPORT" ] ; then
		#echo "Warning: Missing PBI_MAKEPORT for ${pbi}"
		continue
	fi

 	if [ "$PBI_AB_PKGBUILD" = "YES" -a -z "$PBI_AB_NOPKGBUILD"  ] ; then
		# Doing a package build for this PBI
		pkg-static rquery "%v" ${PBI_MAKEPORT} >/dev/null 2>/dev/null
		if [ $? -ne 0 ] ; then
			echo "No package found for: ${PBI_MAKEPORT}"
			continue
		fi
		PBI_PKGNGBUILD="YES" ; export PBI_PKGNGBUILD

	else

		# Doing a port build for this PBI
		if [ ! -d "${PORTSDIR}/${PBI_MAKEPORT}" ] ; then 
			#echo "Skipping invalid port ${PORTSDIR}/${PBI_MAKEPORT}"
			continue
		fi

		# Check if this port can be built on this architecture
		check_port_compat_arch "${PORTSDIR}/${PBI_MAKEPORT}"
		if [ "$?" = "1" ] ; then
			if [ "$PBI_ABFB32" != "YES" ] ; then
				echo "${PBI_MAKEPORT} - Skipping for invalid system arch"
				continue
			fi
			if [ "$have32" != "true" ] ; then
				echo "${PBI_MAKEPORT} - Skipping for invalid system arch"
				continue
			fi
		fi
		unset PBI_PKGNGBUILD

	fi

	# Check if another builder is already doing this port
	pBuilding=0
	for p in `ls ${PBI_TMPDIR}/*.bPort 2>/dev/null`
	do
		if [ "`cat $p`" = "$PBI_MAKEPORT" ] ; then
			pBuilding=1
			break
		fi
	done
	if [ $pBuilding -eq 1 ] ; then
		continue
	fi

	check_ab_needed "$PBI_MAKEPORT" "${PBI_BUILDKEY}" "$_cd" "$PBI_AB_TIMESTAMP"
 	if [ "$?" = "0" ] ; then	
	   AB_FOUND="1"

 	   # Unset the priority if set to 00 / 0
           if [ "${PBI_AB_PRIORITY}" = "00" -o "${PBI_AB_PRIORITY}" = "0" ] ; then 
	   	unset PBI_AB_PRIORITY
           fi

	   # Check the priority of this PBI, see if it rises to the top
	   if [ -z "${CUR_PRIORITY_PBI}" ] ; then 
	     CUR_WORKING_PBI="${pbi}"
	     if [ -z "$PBI_AB_PRIORITY" ] ; then 
                     CUR_PRIORITY_PBI="$internal_ab_priority"
             else
                     CUR_PRIORITY_PBI=`expr $PBI_AB_PRIORITY + 10`
             fi
	     #echo "Setting higher priority target: ${pbi} - Priority: ${CUR_PRIORITY_PBI}"
   	     echo "${CUR_PRIORITY_PBI} $pbi" >> ${PBI_TMPDIR}/.abtmp
             continue
           fi

	   # Bump up the supplied AB priority
	   if [ -n "${PBI_AB_PRIORITY}" ] ; then 
              internal_ab_priority=`expr $PBI_AB_PRIORITY + 10`
	   fi

	   # Check if this PBI is a higher priority
	   if [ $CUR_PRIORITY_PBI -lt $internal_ab_priority ] ; then
	     #echo "Setting higher priority target: ${pbi} - Priority: ${internal_ab_priority}"
	     CUR_WORKING_PBI="${pbi}"
             CUR_PRIORITY_PBI="$internal_ab_priority"
   	     echo "${internal_ab_priority} $pbi" >> ${PBI_TMPDIR}/.abtmp
	     continue
	   else 
	     echo "${internal_ab_priority} $pbi" >> ${PBI_TMPDIR}/.abtmp
	   fi
	   continue
  	 fi

  done

  # Sort the list
  if [ -e "${PBI_TMPDIR}/.abtmp" ] ; then
    sort -n -r ${PBI_TMPDIR}/.abtmp > ${PBI_TMPDIR}/.ablist
    rm ${PBI_TMPDIR}/.abtmp
  fi
}

start_next_ab_target()
{
  local curBuilder="$1"
  # No list to parse?
  if [ ! -e "${PBI_TMPDIR}/.ablist" ] ; then return 0; fi

  # Get the last on the list
  CUR_WORKING_PBI=`cat ${PBI_TMPDIR}/.ablist | head -1 | cut -d ' ' -f 2`
  if [ -z "${CUR_WORKING_PBI}" ] ; then return 0; fi

  cd "${PBI_AB_CONFDIR}"

  # We have something to build lets do it!
  pbi="$CUR_WORKING_PBI"
  unset PBI_MAKEPORT PBI_BUILDKEY PBI_PROGVERSION PBI_REQUIRESROOT PBI_PROGNAME PBI_PROGWEB PBI_PROGAUTHOR PBI_PROGICON PBI_MKPORTBEFORE PBI_MKPORTAFTER PBI_MAKEOPTS PBI_EXCLUDELIST PBI_AB_PRIORITY PBI_AB_NOTMPFS PBI_PROGREVISION PBI_AB_NOPKGBUILD PBI_PKGNGBUILD
  . ${pbi}

  _cd=$(dirname $pbi | sed 's|./||')
  PBI_CONFDIR="$_cd"

  if [ -z "${PBI_MAKEPORT}" ] ; then
     PBI_MAKEPORT=$(dirname $pbi | sed 's|./||')
  fi	

  # Remove any trailing '/'
  echo $PBI_MAKEPORT | grep -q "/$"
  if [ $? -eq 0 ] ; then
    PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  fi

  if [ "$PBI_AB_PKGBUILD" = "YES" -a -z "$PBI_AB_NOPKGBUILD"  ] ; then
     ttag="package"
     PBI_PKGNGBUILD="YES"
  else
     ttag="source"
     unset PBI_PKGNGBUILD
  fi

  # Get the prog version
  get_pbi_progversion

  echo "==> Starting $ttag build [$curBuilder]: $PBI_MAKEPORT"
  echo "$PBI_MAKEPORT" >${PBI_TMPDIR}/${curBuilder}.bPort

  # Remove this from the queue
  cat ${PBI_TMPDIR}/.ablist | tail -n +2 > ${PBI_TMPDIR}/.abtmp
  mv ${PBI_TMPDIR}/.abtmp ${PBI_TMPDIR}/.ablist

  # Start the build now
  start_ext_ab "$PBI_MAKEPORT" \
  "${PBI_BUILDKEY}" "${PBI_PROGVERSION}" \
  "${_cd}" "${PBI_AB_OUTDIR}" "${PBI_AB_TIMESTAMP}" "${curBuilder}"

  return 1
};

# Prune any outdir files which don't have matching modules
do_pbi_autob_prune() {
	if [ "${PBI_AB_PRUNE}" != "YES" ] ; then return 0 ; fi

	echo "=> Cleaning outgoing directory..."
    	# Prune outgoing dirs which don't have matching modules anymore
	cd "${PBI_AB_OUTDIR}"
	for i in `find . -type d | grep -v '\.svn'`
	do
		if [ "${i}" = "." -o "${i}" = ".." ] ; then continue ; fi
		_pDir=`dirname ${i}`
		if [ -d "${i}" -a -n "${i}" ] ; then
    			if [ ! -e "${PBI_AB_CONFDIR}/${_pDir}" ] ; then
      			# Not in our module tree anymore, remove it
      			echo "Auto-Prune: ${PBI_AB_OUTDIR}/${_pDir}"
      			rm -rf "${PBI_AB_OUTDIR}/${_pDir}"
    			fi
  		fi
	done
	cd
}

# Start the pbi_makeport process
start_ext_ab() {
	_mp="${1}"
	_bk="${2}"
	_pv="${3}"
	_cd="${4}"
	_od="${5}/${_cd}"
	local _abkey="$6"
	local eBuilder="$7"
	_flags=""
	_flags="-c ${_cd} -d ${PORTSDIR} -o ${_od} --delbuild"
	if [ -n "${PBI_AB_SSLPRIVKEY}" ] ; then
		_flags="${_flags} --sign ${PBI_AB_SSLPRIVKEY}"
	fi

	# Check if we need to enable tmpfs
 	if [ "$PBI_AB_TMPFS" = "YES" ] ; then
		if [ -z "${PBI_AB_NOTMPFS}" -o "$PBI_AB_NOTMPFS" != "YES" ] ; then
		   	_flags="${_flags} --tmpfs"
		fi
	fi

	# Check if we need to enable pkgbuilding
 	if [ "$PBI_AB_PKGBUILD" = "YES" -a -z "$PBI_AB_NOPKGBUILD"  ] ; then
		_flags="${_flags} --pkgbuild"
	fi

	# Are we doing 32bit builds?
 	if [ "$PBI_AB32" = "YES" ] ; then _flags="${_flags} -32"; fi

        # Check if this port can be built on this architecture
        check_port_compat_arch "${PORTSDIR}/${_mp}"
        if [ $? -ne 0 ] ; then
           if [ "$PBI_ABFB32" = "YES" -a "$have32" = "true" ] ; then
 	      _flags="${_flags} -32"
           fi
        fi

	get_pbi_progversion

	#echo "Starting build of ${_mp} - ${_pv}"
	#echo "pbi_makeport ${_flags} ${_mp}"

	if [ ! -d "${_od}" ] ; then mkdir -p "${_od}" ; fi

	# Save the autobuild key
	echo "$_abkey" > ${_od}/.abkey
	
	# Save the build key for this PBI
	if [ -n "$_bk" ] ; then
		echo "$_bk" > "${_od}/pbi-buildkey"
	else
		echo "__NONE__" > "${_od}/pbi-buildkey"
	fi

	# Clean old log files
	if [ -e "${_od}/build.log" ] ; then
		rm "${_od}/build.log"
	fi
	if [ -e "${_od}/build.log.bz2" ] ; then
		rm "${_od}/build.log.bz2"
	fi

	# Move old PBIs to archived folder
        oldVersion=`cat ${_od}/pbi-version 2>/dev/null`
	if [ "$oldVersion" != "$PBI_PROGVERSION" ]; then
		#echo "Archiving old PBIs..."
		archive_old_pbis "${_od}" "$PBI_AB_ARCHIVENUM"
	fi

	# Set some variables we can call in pbi_makeport
	PBI_AB_TMPDIR="${PBI_TMPDIR}"
	PBI_AB_BUILDER="$eBuilder"
	export PBI_AB_TMPDIR PBI_AB_BUILDER

	# Add some header info to log file
	echo "Starting build: `date`" >${_od}/build.log
	echo "For ${_mp} - ${PBI_PROGVERSION}" >>${_od}/build.log
	echo "Build Command:" >>${_od}/build.log
	echo "pbi_makeport ${_flags} ${_mp}" >>${_od}/build.log
	echo "------------------------------------------------------" >>${_od}/build.log
	
	echo "${_od}" > "${PBI_TMPDIR}/${PBI_AB_BUILDER}.od"
	echo "${_mp}" > "${PBI_TMPDIR}/${PBI_AB_BUILDER}.mp"
	echo "${_cd}" > "${PBI_TMPDIR}/${PBI_AB_BUILDER}.cd"
	echo "${PBI_PROGVERSION}" > "${PBI_TMPDIR}/${PBI_AB_BUILDER}.pv"
	pbi_makeport ${_flags} ${_mp} >>${_od}/build.log 2>>${_od}/build.log &
  	echo "$!" > ${PBI_TMPDIR}/${eBuilder}.pid

}

ab_post_build() 
{
	local build=$1
	_od="`cat ${PBI_TMPDIR}/${build}.od`"
	_mp="`cat ${PBI_TMPDIR}/${build}.mp`"
	_cd="`cat ${PBI_TMPDIR}/${build}.cd`"
	_pv="`cat ${PBI_TMPDIR}/${build}.pv`"
	sleep 1

	if [ -e "${PBI_TMPDIR}/${build}.result" -a "`cat ${PBI_TMPDIR}/${build}.result`" = "0" ] ; then

		echo "===> Build of ${_mp} (${_pv}) was successfull! [$build]"

		echo "${_pv}" > "${_od}/pbi-version"
		echo "OK" > "${_od}/pbi-result"

		# Save the mdate file
		date "+%Y%m%d %H%M%S" >${_od}/pbi-mdate

		if [ -n "${PBI_AB_HELPS}" ] ; then
			${PBI_AB_HELPS} "OK" "${_od}"
		fi

		# Copy over a description file
		if [ -e "${PORTSDIR}/${_mp}/pkg-descr" ] ; then
			cp "${PORTSDIR}/${_mp}/pkg-descr" "${_od}/pbi-descr"
		fi
		if [ -e "${PBI_AB_CONFDIR}/${_cd}/pbi-descr" ] ; then
			cp "${PBI_AB_CONFDIR}/${_cd}/pbi-descr" "${_od}/pbi-descr"
		fi

		rm "${_od}/build.log.bz2" >/dev/null 2>/dev/null
		bzip2 "${_od}/build.log"

	else
		echo "===> Build of ${_mp} failed! [$build]"
		echo "Failed" > "${_od}/pbi-result"
		if [ -n "${PBI_AB_HELPS}" ] ; then
			${PBI_AB_HELPS} "FAILED" "${_od}"
		fi
	fi

}

# Read the version from a PBI file
get_ver_from_pbi_file() 
{
	VAL="`pbi_add -i $1 | grep Version: | cut -d ':' -f 2 | tr -d ' '`"
	export VAL
}

# Read the version from a PBI file
get_progname_from_pbi_file() 
{
	VAL="`pbi_add -i $1 | grep Name: | cut -d ':' -f 2 | tr -d ' '`"
	export VAL
}

get_prefix_from_pbi_file()
{
	VAL="`pbi_add -i $1 | grep Prefix: | cut -d ':' -f 2 | tr -d ' '`"
	export VAL
}

get_mdate_from_pbi_file()
{
	VAL="`pbi_add -i $1 | grep Built: | cut -d ' ' -f 2-5 | tr -s ' '`"
	export VAL
}

get_arch_from_pbi_file()
{
	VAL="`pbi_add -i $1 | grep Arch: | cut -d ' ' -f 2-5 | tr -s ' '`"
	export VAL
}

# Move old PBIs to the archive
archive_old_pbis()
{
	local _od="$1"
	local _keepnum="$2"

	# Make sure the archived dir exists
	if [ ! -d "${_od}/archived" ] ; then mkdir "${_od}/archived"; fi

	# Make sure we have PBIs to archive
	ls ${_od}/*.pbi >/dev/null 2>/dev/null
        if [ "$?" != "0" ] ; then return ; fi

	#echo "Moving old PBIs from ${_od}/*.pbi -> ${_od}/archived/"
	mv ${_od}/*.pbi ${_od}/archived/ 2>/dev/null
	mv ${_od}/*pbi.sha256 ${_od}/archived/ 2>/dev/null

	# Prune anything beyond the _keepnum
        #echo "Checking for more than $_keepnum PBIs in archive"
	oCount="1"
	for oFile in `ls -t ${_od}/archived/*.pbi 2>/dev/null`
	do
		if [ -z "$oFile" ] ; then continue ; fi
		if [ "$oCount" -gt "$_keepnum" ] ; then
			#echo "Removing old PBI ${oFile} from archive"
			rm ${oFile}*
		fi
		oCount=`expr $oCount + 1`	
	done
}

# Check if we need to do an auto-build of the target PBI
check_ab_needed() {
	_port="$1"
	_bk="$2"
	_cd="$3"
	local _abkey="$4"
        internal_ab_priority="1"
	export internal_ab_priority
        unset PBI_PROGVERSION

	# Check PBI_BUILDKEY, see if we have a manual rebuild triggered
	if [ -e "${PBI_AB_OUTDIR}/${_cd}/pbi-buildkey" ] ; then
		if [ "`cat ${PBI_AB_OUTDIR}/${_cd}/pbi-buildkey`" != "$_bk" \
			 -a -n "${_bk}" ]; then 
                   #echo "$_port BUILDKEY bump, rebuild triggered."
                   internal_ab_priority="9"
                   return 0
                fi
	fi

	# Make sure this PBI hasn't already failed during this run
	if [ -e "${PBI_AB_OUTDIR}/${_cd}/.abkey" -a -e "${PBI_AB_OUTDIR}/${_cd}/pbi-result" ] ; then
	  if [ "`cat ${PBI_AB_OUTDIR}/${_cd}/.abkey`" = "$_abkey" ] ; then
	    if [ "`cat ${PBI_AB_OUTDIR}/${_cd}/pbi-result`" != "OK" ] ; then
              #echo "$_port - Skipping failed from this run"
	      return 1
  	    fi
  	  fi
	fi

	#echo "Checking $_port for rebuild in ${PBI_AB_OUTDIR}/$_cd with key of $_bk"

	# See if we have an existing PBI
	ls ${PBI_AB_OUTDIR}/${_cd}/*.pbi >/dev/null 2>/dev/null
	if [ "${?}" != "0" ]; then 
	  #echo "$_port - No existing PBI"
          internal_ab_priority="8"
          return 0 
        fi

	# See if we have a saved version
	if [ ! -e "${PBI_AB_OUTDIR}/${_cd}/pbi-version" ]; then 
		#echo "No saved pbi-version"
	  	#echo "$_port - No existing version"
          	internal_ab_priority="7"
		return 0
	fi

	# Get the programs port version
	get_pbi_progversion

	# See if the version is different now
	oldVersion=`cat ${PBI_AB_OUTDIR}/${_cd}/pbi-version`
	if [ "$oldVersion" != "$PBI_PROGVERSION" ]; then 
		oldPortVer="`echo $oldVersion | rev | cut -d '_' -f 2- | rev`"
		if [ "$PORTVER" = "$oldPortVer" ] ; then
			# Just a minor portrev bump
          		internal_ab_priority="2"
			#echo "$_port revision bump: $oldVersion -> $PBI_PROGVERSION"
		else
			# Real version change
          		internal_ab_priority="3"
			#echo "$_port version bump: $oldVersion -> $PBI_PROGVERSION"
		fi
		return 0
	fi

	#echo "$_port - is Up2Date!"
	return 1
}

# start processing for make port / pbi compile
pbi_make_init() {

  	require_root

  	parse_make_pbi_cmdline "$@"
 
  	do_pbi_make "$@"
}

do_pbi_make() {

	# See if we need to enable pkgng
	detect_pkgng

  	# Load the PBI settings
	get_pbi_progversion
	get_pbi_progname
  	get_pbi_progdir

	# Check if this is being called from within chroot or outside
	if [ "`basename $0`" = "pbi_makeport" ] ; then
		# Extract the chroot 
		chroot_extract

		# Now re-run pbi_makeport in chroot environment
		chroot "${PBI_CHROOTDIR}" "/usr/local/sbin/pbi_makeport_chroot" "$@"
		_err=$?
		if [ "$_err" = "0" -a "${PBI_BUILDONLY}" != "YES" ] ; then
			mv ${PBI_CHROOTDIR}/pbiout/*.pbi ${PBI_CREATE_OUTDIR}/ 
			mv ${PBI_CHROOTDIR}/pbiout/*.sha256 ${PBI_CREATE_OUTDIR}/
		else
			echo "Error: pbi_makeport_chroot: returned non-0 status!"
		fi

  		# Break here if we are only doing a build
		if [ "${PBI_BUILDONLY}" = "YES" ] ; then exit_trap; fi

		# Lets cleanup the chroot environment
		chroot_make_cleanup
		rm_tmpdir

		# If running as an auto-build, show that we were successful
		if [ -n "$PBI_AB_TMPDIR" ] ; then
        		echo "$_err" > ${PBI_AB_TMPDIR}/${PBI_AB_BUILDER}.result
		fi
		exit $_err
	fi

	if [ "`basename $0`" != "pbi_makeport_chroot" ] ; then return ; fi
	

  	# Check if we have some specific make options to use
  	load_pbi_conffile

  	# init tmpdir
  	init_tmpdir

  	set_make_options

  	# See if we need to run a pre make script
  	run_pbi_preportmake

  	# Start our build
  	start_pbi_mkportbefore
  	start_prebuild_script
  	start_pbi_makeport
  	start_postbuild_script
  	start_pbi_mkportafter

	# Get the version again, in case we installed from pkgng and it doesn't match ports
	get_pbi_progversion

  	# Prune any proto / build specific ports
  	if [ -z "$PBI_PKGNGBUILD" ] ; then
  		start_pbi_prune_ports
	fi

  	# See if we need to run a post make script
  	run_pbi_postportmake

	# Auto-generate a external_links directive from plist info
	mk_auto_ext_linksfile

	# Cleanup any package leftovers
	if [ -d "/usr/local/tmp/All" ] ; then
		rm -rf /usr/local/tmp/All
	fi

  	# Break here if we are only doing a build
	if [ "${PBI_BUILDONLY}" = "YES" ] ; then exit_trap; fi

	# Load any extra meta-data from the package
	load_pkg_metadata

	# Start creation of PBI
	do_pbi_create

	# Got this far, lets exit with success
	rm_buildfiles
	rm_tmpdir

	exit 0
}

# Loads some optional meta-data from the package
load_pkg_metadata()
{
  	# Remove any trailing '/'
  	echo $PBI_MAKEPORT | grep -q "/$"
  	if [ $? -eq 0 ] ; then
     		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|/$||g'`"
  	fi
  	echo $PBI_MAKEPORT | grep -q "^/"
  	if [ $? -eq 0 ] ; then
		PBI_MAKEPORT="`echo $PBI_MAKEPORT | sed 's|^/||g'`"
	fi

	if [ -z "$PBI_LICENSE" ] ; then
		PBI_LICENSE="`pkg rquery '%L' ${PBI_MAKEPORT} | head -n 1`"
	fi
	if [ -z "$PBI_SHORTDESC" ] ; then
		PBI_SHORTDESC="`pkg rquery '%c' ${PBI_MAKEPORT} | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
	fi
	if [ -z "$PBI_MAINTAINER" ] ; then
		PBI_MAINTAINER="`pkg rquery '%m' ${PBI_MAKEPORT}`"
	fi
	if [ -z "$PBI_DESC" ] ; then
		PBI_DESC="`pkg rquery '%e' ${PBI_MAKEPORT} | awk 1 ORS=' ' | sed 's|  |<br>|g' | sed 's|*|-|g'`"
	fi
	if [ -z "$PBI_PROGWEB" ] ; then
		PBI_PROGWEB="`pkg rquery '%w' ${PBI_MAKEPORT}`"
	fi
	if [ -z "$PBI_CATEGORY" ] ; then
		PBI_CATEGORY="`pkg rquery '%C' ${PBI_MAKEPORT} | head -n 1`"
	fi
	if [ -z "$PBI_PROGTYPE" ] ; then
		PBI_PROGTYPE="Text"
	fi
}

# Check if we need to save a list of GROUPS to create at install
mk_pbi_groups_file()
{
	if [ -z "$PBI_BUILD_GROUPS" ] ; then return ; fi

	for group in $PBI_BUILD_GROUPS
	do
		# Check /usr/ports/GIDs for group entry
		gidLine=`cat /usr/ports/GIDs | grep "^$group:"`
		if [ -z "$gidLine" ] ; then
			echo "Warning: No entry for \"$group\" in GIDs file..."
			continue
		fi
		touch ${PBI_STAGEDIRMNT}/${PBI_INS_GROUPSFILE}
		grep -q "^$group:" ${PBI_STAGEDIRMNT}/${PBI_INS_GROUPSFILE}
		if [ $? -ne 0 ] ; then
			echo "Saving gid details for group: $group"
			echo "$gidLine" >> ${PBI_STAGEDIRMNT}/${PBI_INS_GROUPSFILE}
		fi
	done
}

# Check if we need to save a list of users to create at install
mk_pbi_users_file()
{
	if [ -z "$PBI_BUILD_USERS" ] ; then return ; fi

	for user in $PBI_BUILD_USERS
	do
		# Check /usr/ports/UIDs for user entry
		uidLine=`cat /usr/ports/UIDs | grep "^$user:"`
		if [ -z "$uidLine" ] ; then
			echo "Warning: No entry for \"$user\" in UIDs file..."
			continue
		fi
		touch ${PBI_STAGEDIRMNT}/${PBI_INS_USERSFILE}
		grep -q "^$user:" ${PBI_STAGEDIRMNT}/${PBI_INS_USERSFILE}
		if [ $? -ne 0 ] ; then
			echo "Saving uid details for user: $user"
			echo "$uidLine" >> ${PBI_STAGEDIRMNT}/${PBI_INS_USERSFILE}
		fi
	done
}

# Source any pre-build script to allow a custom script to modify the port
start_prebuild_script()
{
	if [ -e "/pre-build.sh" ] ; then
		chmod 755 /pre-build.sh
		# Source the script
		. /pre-build.sh
	fi
}

# Source any post-build script to allow a custom script to modify the port
start_postbuild_script()
{
	if [ -e "/post-build.sh" ] ; then
		chmod 755 /post-build.sh
		# Source the script
		. /post-build.sh
	fi
}

# Check if we created any linux stuff, and copy it into the correct PREFIX
auto_copy_linuxbase()
{
	if [ -d "/compat/linux/usr/lib" ] ; then
		mkdir ${PBI_PROGDIRPATH}/linuxlib
		echo "Copying /compat/linux -> ${PBI_STAGEDIRMNT}/linux"
		tar cf - -C /compat/linux . 2>/dev/null | \
		tar xf - -C ${PBI_STAGEDIRMNT}/linux 2>/dev/null
	fi
}

# Clean the chroot environment
chroot_make_cleanup() {
	[ -z "${PBI_CHROOTDIR}" ] && return
	[ -d "${PBI_CHROOTDIR}" ] || return
	[ "${PBI_CHROOTDIR}" = "/" ] && return
	
	# Unmount /dev if mounted
	echo "Cleaning $PBI_CHROOTDIR"
	umount -f ${PBI_CHROOTDIR}/dev >/dev/null 2>/dev/null
	umount -f ${PBI_CHROOTDIR}/compat/linux/proc >/dev/null 2>/dev/null
	umount -f ${PBI_CHROOTDIR}/usr/ports >/dev/null 2>/dev/null
	umount -f ${PBI_CHROOTDIR}/pkgs >/dev/null 2>/dev/null
	umount -f ${PBI_CHROOTDIR}/.ccache >/dev/null 2>/dev/null
	umount -f ${PBI_CHROOTDIR}/usr/wrkdirprefix >/dev/null 2>/dev/null

	# Sleep a moment before we try this again, seems it takes a moment to clear up
	sleep 2
	umount -f ${PBI_CHROOTDIR}/dev >/dev/null 2>/dev/null

	if [ "${PBI_KEEPBUILDFILES}" = "YES" ] ; then return ; fi

	# Cleanup ZFS dataset
        isDirZFS "${PBI_CHROOTDIR}" "1"
        if [ $? -eq 0 ] ; then
   	     tank=`getZFSTank "$PBI_CHROOTDIR"`
	     sleep 1
	     # If we are running as a result of pbi_autobuild, let it do the ZFS cleanup
	     if [ -z "${PBI_AB_TMPDIR}" ] ; then
             	zfs destroy -r "${tank}${PBI_CHROOTDIR}"
  	     	rmdir "${PBI_CHROOTDIR}" >/dev/null 2>/dev/null
	     fi
	     return
        fi

	# Cleanup normal directory
	rm -rf "${PBI_CHROOTDIR}" >/dev/null 2>/dev/null
	chflags -R noschg ${PBI_CHROOTDIR} >/dev/null 2>/dev/null
	rm -rf "${PBI_CHROOTDIR}" >/dev/null 2>/dev/null
}

# Function which extracts the clean chroot environment for the PBI
chroot_extract() {

	# If no freebsd base exists, make it first
	PBI_WORLDCHROOT="${PBI_APPDIR}/.pbi-world-$ARCH"
	export PBI_WORLDCHROOT
	[ -e "${PBI_WORLDCHROOT}/COPYRIGHT" ] || mk_chroot_file

	# Set the chroot path
	PBI_CHROOTDIR="${PBI_PROGDIRPATH}.chroot.$$"
	export PBI_CHROOTDIR
	
	# See if there is old chroot to clean first
	chroot_make_cleanup

	# Create the new chroot dir
	mkdir -p "${PBI_CHROOTDIR}"

	# If on ZFS, we can just clone our existing base system
	isDirZFS "${PBI_APPDIR}"
        if [ $? -eq 0 ] ; then   
           tank=`getZFSTank "$PBI_WORLDCHROOT"`
	   echo "Cloning ${PBI_WORLDCHROOT} -> ${PBI_CHROOTDIR}"
	   if [ -n "${PBI_AB_TMPDIR}" ] ; then
              echo "${tank}${PBI_CHROOTDIR}" > ${PBI_AB_TMPDIR}/${PBI_AB_BUILDER}.zmnt
	   fi
           zfs clone ${tank}${PBI_WORLDCHROOT}@clean ${tank}${PBI_CHROOTDIR}
	   if [ $? -ne 0 ] ; then exit_err "Failed creating clean ZFS base snapshot"; fi
	else
	   echo "Creating chroot environment..."
	   tar cf - -C ${PBI_WORLDCHROOT} . | tar xf - -C "${PBI_CHROOTDIR}" 2>/dev/null
	   [ $? -ne 0 ] && exit_err "Failed copying chroot environment!"
	fi

	# If we plan on using TMPFS mount it now
	mkdir -p ${PBI_CHROOTDIR}/usr/wrkdirprefix
	if [ "$MKTMPFS" = "YES" ] ; then 
		mount -t tmpfs tmpfs ${PBI_CHROOTDIR}/usr/wrkdirprefix
	fi

	# Copy resolv.conf
	cp /etc/resolv.conf ${PBI_CHROOTDIR}/etc/resolv.conf

	# Copy our binary wrapper
	PBI_WRAPPERFILE="${PBI_SHARE_DIR}/.pbiwrapper-$ARCH"
	cp ${PBI_WRAPPERFILE} ${PBI_CHROOTDIR}/.pbiwrapper-$ARCH

	# If we are doing a PKGNG build, lets set it up
	if [ "$PBI_PKGNGBUILD" = "YES" ] ; then
		mkdir -p ${PBI_CHROOTDIR}/usr/local/etc 2>/dev/null
	   	cp /usr/local/etc/pkg.conf ${PBI_CHROOTDIR}/usr/local/etc/pkg.conf
		# Copy over the pkg/repo and friends
	   	cp -r /usr/local/etc/pkg ${PBI_CHROOTDIR}/usr/local/etc/

		# Install pkgng into the chroot
		# This can fail when we run multiple builders at once,
		# due to the pkgng DB being locked :(

		# For now try multiple times, this should be revisited with
		# a cleaner solution at some point
		tries=0
		while :
		do
			pkg-static -c ${PBI_CHROOTDIR} install -y ports-mgmt/pkg
			if [ $? -eq 0 ] ; then break ; fi

			if [ $tries -gt 10 ] ; then
				exit_err "Failed installing pkgng into chroot"
			else
				sleepRand="`jot -r 1 1 90`"
				echo "Pkgng is busy, trying again in $sleepRand seconds"
				sleep $sleepRand
				tries=`tries expr + 1`
			fi
		done

	fi

	# If we have a custom PBI_MAKECONF include it
	[ -e "${PBI_MAKECONF}" ] && cp ${PBI_MAKECONF} ${PBI_CHROOTDIR}/etc/make.conf

	# Set any target arch vars
        if [ "${ARCH}" = "i386" -a "${REALARCH}" = "amd64" ];then
                LOGIN_ENV=",UNAME_p=i386,UNAME_m=i386"
                cat >> ${PBI_CHROOTDIR}/etc/make.conf << EOF
ARCH=i386
MACHINE=i386
MACHINE_ARCH=i386
EOF
        	sed -i .back -e "s/:\(setenv.*\):/:\1${LOGIN_ENV}:/" ${PBI_CHROOTDIR}/etc/login.conf
        	cap_mkdb ${PBI_CHROOTDIR}/etc/login.conf
        fi

	#echo "Copying ${PORTSDIR} -> ${PBI_CHROOTDIR}/usr/ports"
	#tar cvf - -C "${PORTSDIR}" --exclude ./distfiles . 2>/dev/null | tar xvf - -C "${PBI_CHROOTDIR}/usr/ports" 2>/dev/null
	[ -d "${PORTSDIR}/distfiles" ] || mkdir -p ${PORTSDIR}/distfiles
	mkdir -p ${PBI_CHROOTDIR}/usr/ports 2>/dev/null
	mount_nullfs ${PORTSDIR} ${PBI_CHROOTDIR}/usr/ports

	# Now copy over the pbi_* scripts
	mkdir ${PBI_CHROOTDIR}/usr/local/sbin 2>/dev/null
	cp ${PROGBASE}/sbin/pbi_* ${PBI_CHROOTDIR}/usr/local/sbin

	# Copy the functions.sh
	mkdir -p ${PBI_CHROOTDIR}/usr/local/share/pcbsd/scripts/
	cp ${PROGBASE}/share/pcbsd/scripts/functions.sh ${PBI_CHROOTDIR}/usr/local/share/pcbsd/scripts/

	# Copy over the pbi_makeport app
	cp ${PBI_CHROOTDIR}/usr/local/sbin/pbi_makeport ${PBI_CHROOTDIR}/usr/local/sbin/pbi_makeport_chroot
	chmod 755 ${PBI_CHROOTDIR}/usr/local/sbin/pbi_*

	# Copy the default icons
	cp ${PBI_DEFAULT_ICON} ${PBI_CHROOTDIR}${PBI_DEFAULT_ICON_CHROOT}

	# Make sure the outgoing dir is created
	mkdir -p ${PBI_CHROOTDIR}/pbiout 2>/dev/null

	# Copy over the PBI DB
	mkdir -p ${PBI_CHROOTDIR}/var/db 2>/dev/null
	cp -r ${PBI_DBDIR} ${PBI_CHROOTDIR}${PBI_DBDIR}
	
	# Copy over the confdir as well
	if [ -n "${PBI_CONFDIR}" ] ; then
		mkdir -p "${PBI_CHROOTDIR}/pbimodule"
		echo "Copying ${PBI_CONFDIR} -> ${PBI_CHROOTDIR}/pbimodule"
		tar cf - -C "${PBI_CONFDIR}" . 2>/dev/null | tar xf - -C "${PBI_CHROOTDIR}/pbimodule" 2>/dev/null
	fi

	# Copy over the ssl priv key if used
	if [ -n "$PBI_SSLPRIVKEY" ] ; then
	 	cp "${PBI_SSLPRIVKEY}" "${PBI_CHROOTDIR}/privkey.pem"
		chmod 600 "${PBI_CHROOTDIR}/privkey.pem"
	fi

	# Check if we have a pre-make script to run
	if [ -n "${PBI_PREMAKE_SCRIPT}" ] ; then
		if [ -e "${PBI_PREMAKE_SCRIPT}" ] ; then
			cp ${PBI_PREMAKE_SCRIPT} ${PBI_CHROOTDIR}/pre-build.sh
		fi
	fi
	# Check if we have a post-make script to run
	if [ -n "${PBI_POSTMAKE_SCRIPT}" ] ; then
		if [ -e "${PBI_POSTMAKE_SCRIPT}" ] ; then
			cp ${PBI_POSTMAKE_SCRIPT} ${PBI_CHROOTDIR}/post-build.sh
		fi
	fi

	# Do we have a user-supplied meta-file to include in the PBI?
	if [ -n "${PBI_CREATE_USERMETA}" ] ; then
	   cp "$PBI_CREATE_USERMETA" ${PBI_CHROOTDIR}/user-meta
	fi

	# Start devfs in the chroot
	if [ ! -d "${PBI_CHROOTDIR}/dev" ] ; then
		mkdir ${PBI_CHROOTDIR}/dev
	fi
	mount -t devfs devfs ${PBI_CHROOTDIR}/dev

	# Mount linprocfs
	mkdir -p ${PBI_CHROOTDIR}/compat/linux/proc >/dev/null 2>/dev/null
	mount -t linprocfs linprocfs ${PBI_CHROOTDIR}/compat/linux/proc

	# Make sure the outgoing dir exists
	mkdir -p ${PBI_CHROOTDIR}${PBI_CREATE_OUTDIR} >/dev/null 2>/dev/null

	# Check for ccache being enabled on the host and nullfs mount it to the chroot
	if [ -n "${CCACHE_DIR}" -a -d "${CCACHE_DIR}" -a "$PBI_PKGNGBUILD" != "YES" ] ; then
		mkdir ${PBI_CHROOTDIR}/.ccache
		mount_nullfs ${CCACHE_DIR} ${PBI_CHROOTDIR}/.ccache	
	fi

}

# No chroot environment tar file exists yet, lets build or extract
mk_chroot_file() {

	# Check if on PC-BSD and we can instead fetch fbsd-release.txz
	if [ -e "$PCBSD_ETCCONF" -a -z "$FORCE_FBSD_ONLY" ]; then

	  cd "$PBI_APPDIR"

  	  # Get the system version we are checking for updates to
  	  SYSVER="`uname -r | cut -d '-' -f 1-2`" ; export SYSVER

          local dFiles="base.txz doc.txz games.txz src.txz"
          if [ "$ARCH" = "amd64" ] ; then
             dFiles="$dFiles lib32.txz"
          fi

          echo "Fetching chroot environment. This may take a while..."
          for i in $dFiles
          do
            echo "Downloading /${SYSVER}/${ARCH}/dist/${i} ..."
            get_file_from_mirrors "/${SYSVER}/${ARCH}/dist/${i}" "${i}" "iso"
            [ $? -ne 0 ] && exit_err "Error while downloading the freebsd world."
          done

	  # Create the WORLDCHROOT
	  isDirZFS "${PBI_APPDIR}"
          if [ $? -eq 0 ] ; then   
            # Use ZFS base for cloning
	    echo "Creating ZFS ${PBI_WORLDCHROOT} dataset..."
            tank=`getZFSTank "$PBI_APPDIR"`
	    isDirZFS "${PBI_WORLDCHROOT}" "1"
            if [ $? -ne 0 ] ; then   
              zfs create -o mountpoint=${PBI_WORLDCHROOT} -p ${tank}${PBI_WORLDCHROOT}
	      if [ $? -ne 0 ] ; then exit_err "Failed creating ZFS base dataset"; fi
	    fi
	  else
            mkdir ${PBI_WORLDCHROOT}
	  fi

 	  # Extract dist files
          for i in $dFiles
          do
            tar xpf ${i} -C ${PBI_WORLDCHROOT} 2>/dev/null
            if [ $? -ne 0 ] ; then exit_err "Failed extracting freebsd environment"; fi
            rm ${i}
          done

          # Create the clean snapshot
	  isDirZFS "${PBI_APPDIR}"
          if [ $? -eq 0 ] ; then   
            zfs snapshot ${tank}${PBI_WORLDCHROOT}@clean
	    if [ $? -ne 0 ] ; then exit_err "Failed creating clean ZFS base snapshot"; fi
          fi

	  return
 	fi

        local _srcdir="/usr/src"
        if [ -z "${PBI_BUILDSRC}" ] ; then
                PBI_BUILDSRC="${_srcdir}"
        fi

        local _targetDir="${PBI_WORLDCHROOT}"
        if [ -z "${PBI_BUILDTARGET}" ] ; then
                PBI_BUILDTARGET="${_targetDir}"
        fi

        # Delete source code/build if not /usr/src and PBI_DELETE_BUILD is true
        if [ -z "${PBI_DELETE_BUILD}" ] ; then
                PBI_DELETE_BUILD=1
        fi
 
	# Use existing sources
        if [ -e "${PBI_BUILDSRC}/COPYRIGHT" -a -z "${PBI_OSREL}" ] ; then
		PBI_BUILDLOG="${PBI_APPDIR}/.buildWorldLog"
		: > ${PBI_BUILDLOG}
		mkdir -p "${PBI_BUILDTARGET}"
	
	else
		# Make sure SVN is installed
		which svn >/dev/null 2>/dev/null
		[ "$?" -ne 0 ] && exit_err "Subversion is required to rebuild the chroot environment!"

                local _osRel=$FBSDREL
                if [ -n "${PBI_OSREL}" ]; then
                        _osRel="${PBI_OSREL}"
                fi

		echo "Building the PBI chroot environment... This may take a while..."
		PBI_BUILDLOG="${PBI_APPDIR}/.buildWorldLog"
		echo "" > ${PBI_BUILDLOG}
		mkdir -p "${PBI_BUILDSRC}"
		mkdir -p "${PBI_BUILDTARGET}"
	
		# Figure out which version of FreeBSD to checkout
		case $_osRel in
			*RELEASE)
				local _osMajor=${_osRel%%.*}
				local svnUrl="svn://svn.freebsd.org/base/releng/${_osMajor}.0"
				echo "Using $svnUrl for sources"
				;;
			*CURRENT)
				local svnUrl="svn://svn.freebsd.org/base/head"
				echo "Using $svnUrl for sources"
				;;
			*STABLE)
				local _osMajor=${_osRel%%.*}
				local svnUrl="svn://svn.freebsd.org/base/stable/${_osMajor}"
				"Using $svnUrl for sources"
				;;
			*)
				local svnUrl="svn://svn.freebsd.org/base/head"
				echo "Using $svnUrl for sources"
				echo "Assuming a BETA|RC or rarely used FreeBSD version. Using CURRENT!"
				;;
		esac

		echo "Checking out FreeBSD sources from $svnUrl"
                if [ -e "${PBI_BUILDSRC}/COPYRIGHT" ] ; then
                        svn update ${PBI_BUILDSRC} >>${PBI_BUILDLOG} 2>>${PBI_BUILDLOG}
                else
                        svn co ${svnUrl} ${PBI_BUILDSRC} >>${PBI_BUILDLOG} 2>>${PBI_BUILDLOG}
                fi

                if [ "$?" != "0" ] ; then
                        if [ "${PBI_DELETE_BUILD}" = "1" ] ; then
                                rm -rf "${PBI_BUILDSRC}"
                                rm -rf "${PBI_BUILDTARGET}"
                        fi
			exit_err "Subversion checkout failed! Logfile saved: ${PBI_BUILDLOG}"
		fi
	fi # End of subversion checkout

	echo "Running buildworld / installworld (into a chroot)"
	touch ${PBI_BUILDSRC}/Makefile
	cd ${PBI_BUILDSRC}
        make ${PBI_BUILDFLAGS} TARGET=$ARCH buildworld >>${PBI_BUILDLOG} 2>>${PBI_BUILDLOG}
        if [ "$?" != "0" ] ; then
                cd
                if [ "${PBI_BUILDSRC}" != "/usr/src" -a "${PBI_DELETE_BUILD}" != "0" ] ; then
                        rm -rf "${PBI_BUILDSRC}"
                        rm -rf "${PBI_BUILDTARGET}"
                fi
                exit_err "Buildworld failed! Logfile saved: ${PBI_BUILDLOG}"
        fi

	# See if we need to create a ZFS dataset
	isDirZFS "${PBI_APPDIR}"
        if [ $? -eq 0 ] ; then   
            # Use ZFS base for cloning
	    echo "Creating ZFS ${PBI_WORLDCHROOT} dataset..."
            tank=`getZFSTank "$PBI_APPDIR"`
	    isDirZFS "${PBI_WORLDCHROOT}" "1"
            if [ $? -ne 0 ] ; then   
              zfs create -o mountpoint=${PBI_WORLDCHROOT} -p ${tank}${PBI_WORLDCHROOT}
	      if [ $? -ne 0 ] ; then exit_err "Failed creating ZFS base dataset"; fi
	    fi
	fi

        make ${PBI_BUILDFLAGS} installworld TARGET=$ARCH DESTDIR=${PBI_BUILDTARGET} >>${PBI_BUILDLOG} 2>>${PBI_BUILDLOG}
        if [ "$?" != "0" ] ; then
                cd
                if [ "${PBI_BUILDSRC}" != "/usr/src" -a "${PBI_DELETE_BUILD}" != "0" ] ; then
                        rm -rf "${PBI_BUILDSRC}"
                        rm -rf "${PBI_BUILDTARGET}"
                fi
                exit_err "Buildworld failed! Logfile saved: ${PBI_BUILDLOG}"
        fi
        make ${PBI_BUILDFLAGS} distribution TARGET=$ARCH DESTDIR=${PBI_BUILDTARGET} >>${PBI_BUILDLOG} 2>>${PBI_BUILDLOG}
        if [ "$?" != "0" ] ; then
                cd
                if [ "${PBI_BUILDSRC}" != "/usr/src" -a "${PBI_DELETE_BUILD}" != "0" ] ; then
                        rm -rf "${PBI_BUILDSRC}"
                        rm -rf "${PBI_BUILDTARGET}"
                fi
                exit_err "Buildworld failed! Logfile saved: ${PBI_BUILDLOG}"
        fi

	# Copy the source since some ports need kern sources
	echo "Copying FreeBSD sources to chroot environment"
	mkdir -p ${PBI_BUILDTARGET}/usr/src >/dev/null 2>/dev/null
	tar cf - -C "${PBI_BUILDSRC}" --exclude "\.svn/" . 2>/dev/null | tar xf - -C "${PBI_BUILDTARGET}/usr/src" 2>/dev/null
	cd

	# Cleanup after ourselves
	chflags -R noschg "${PBI_BUILDTARGET}" >/dev/null 2>/dev/null
        if [ "${PBI_BUILDSRC}" != "/usr/src" -a "${PBI_DELETE_BUILD}" != "0" ] ; then
                rm -rf "${PBI_BUILDSRC}"
        fi
        if [ "${PBI_DELETE_BUILD}" = "1" ] ; then
                rm -rf "${PBI_BUILDTARGET}" >/dev/null 2>/dev/null
        fi
	rm ${PBI_BUILDLOG}

	# If on ZFS, create snapshot
	isDirZFS "${PBI_APPDIR}"
	if [ $? -eq 0 ] ; then
           	zfs snapshot ${tank}${PBI_WORLDCHROOT}@clean
	    	if [ $? -ne 0 ] ; then exit_err "Failed creating clean ZFS base snapshot"; fi
		rm ${PBI_BUILDLOG}
		return
	fi

}

# Read the target ports plist, and generate a external_links config based upon it
mk_auto_ext_linksfile() {
	# Get ports name
	get_pkgname "${PBI_MAKEPORT}"
	_pname="${PKGNAME}"

 	pkg info -l ${_pname} | sed "s|/usr/local/||g" \
		| grep -v -e "^Information for" -e "^Files:" -e "owns the following" \
		| tr -s '\t' ' ' \
		| tr -d ' ' \
		 > "${PBI_TMPDIR}/.pkg_flist.$$"

	if [ ! -d "${PBI_PROGDIRPATH}" ] ; then
		mkdir -p "${PBI_PROGDIRPATH}"
	fi
	_ef="${PBI_TMPDIR}/${MOD_AUTOEXTLINKFILE}"

	[ -e "$_ef" ] && rm "$_ef"

	while read f
	do
		bin="NO"
		[ -z "${f}" ] && continue
		[ -e "/usr/local/${f}" ] || continue

		# Strip out anything not in:
		dirname ${f} | grep -q -e "^bin" -e "^sbin" -e "^etc/rc.d" -e "^man" -e "^info"
		[ $? -ne 0 ] && continue

		# See if this is executable and set it as binary
		dirname ${f} | grep -q -e "^bin" -e "^sbin" -e "^etc/rc.d"
		if [ -x "/usr/local/${f}" -a $? -eq 0 ] ; then

		   # Check this executable, if Linux binary, flag it
		   file "/usr/local/${f}" | grep -iq "Linux"
		   if [ $? -ne 0 ] ; then
	  	      echo "${f}	${f}	binary,nocrash" >> "$_ef"
		   else
	  	      echo "${f}	${f}	linux,nocrash" >> "$_ef"
 		   fi
		else
			echo "${f}	${f}	replace" >> "$_ef"
		fi
	done < ${PBI_TMPDIR}/.pkg_flist.$$
	rm "${PBI_TMPDIR}/.pkg_flist.$$"
}

# Init the crash handler routine
pbi_crash_init() {
	which "pbi-crashhandler-gui" >/dev/null 2>/dev/null
	if [ "$?" = "0" -a -n "${DISPLAY}" ] ; then
		#pbi-crashhandler-gui "$@"
	fi
}

# Cleanup after caught exit
exit_trap() {
	# If a download is running, kill it
	if [ -n  "${FETCH_PID}" ] ; then 
	   echo "Killing ${FETCH_PID}"
	   kill -s INT ${FETCH_PID}
           sleep 2
	fi

	# If we are running as an auto-build service we need to cleanup
	if [ "`basename ${0}`" = "pbi_autobuild" ] ; then
	   for j in `ls ${PBI_TMPDIR}/*.pid 2>/dev/null`
	   do
	      bNum=`basename $j | cut -d '.' -f 1 `
	      if pgrep -qF "${j}" >/dev/null 2>&1; then 
	         echo "===>Cleaning up processes [$bNum]"
		 pkill -9 -P "`cat ${j}`"
		 sleep 10 
		 pkill -9 -F ${j}
 		 sleep 10 
		 # Do the ZFS destroy here, since running zfs destroy concurrently as we cleanup can cause a panic
		 check_zfs_ab_destroy "$bNum"
	      fi
	   done
	fi

        chroot_make_cleanup
	rm_tmpdir
	exit 0
}

# Read in the global pbi.conf
load_pbi_etcconf() {

	# FTP_PASSIVE_MODE needs to be enabled by default
	FTP_PASSIVE_MODE=YES
	export FTP_PASSIVE_MODE

	PBI_PUBKEYS="`ls ${PBI_DBKEYDIR}/*.ssl 2>/dev/null`"

	[ -e "${PBI_ETCCONF}" ] || return 0

	# See if we have a custom index refresh rate
	_ckPBIIR="`sed -n 's/^PBI_INDEXREFRESH: //gp' ${PBI_ETCCONF}`"
	if [ -n "${_ckPBIIR}" -a $(is_num "$_ckPBIIR") ] ; then 
		PBI_INDEXREFRESH="${_ckPBIIR}"
	fi

	# See if we have a custom pbid refresh time
	_ckPBID="`cat ${PBI_ETCCONF} | grep '^PBID_REFRESH: ' | sed 's|PBID_REFRESH: ||g'`"
	if [ -n "${_ckPBID}" -a $(is_num "$_ckPBID") ] ; then 
		PBIDSLEEP="${_ckPBID}"
	fi

}

# Build the specified port
do_port_build()
{
  local _lPortRaw="$1"
  local pkgName=""

  # Remove any trailing '/'
  echo $_lPortRaw | grep -q "/$"
  if [ $? -eq 0 ] ; then
     _lPortRaw="`echo $_lPortRaw | sed 's|/$||g'`"
  fi

  local _lPort="/usr/ports/$_lPortRaw"

  echo "Checking port: $_lPort"

  if [ -n "$PBI_PKGNGBUILD" ] ; then
     pkgName=`pkg-static rquery '%n' $_lPortRaw`
  else
     pkgName=`make -V PKGNAME -C $_lPort PORTSDIR=${PORTSDIR}`
  fi

  # Make sure this port isn't already loaded
  pkg info -e ${pkgName}
  if [ $? -eq 0 ] ; then return ; fi

  # Are we doing a PKGNG build?
  if [ -n "$PBI_PKGNGBUILD" ] ; then
	pkg install -y "$_lPortRaw"
	if [ $? -ne 0 ] ; then
	   exit_err "Failed installing $_lPortRaw"
	fi

	# Did it install?
    	pkg info -e ${_lPortRaw}
    	if [ $? -ne 0 ] ; then exit_err "Failed to install $_lPortRaw" ; fi

  	# Save any users / groups we need to create later
  	local pUsers="`pkg query "%U" $_lPortRaw`"
  	local pGroups="`pkg query "%G" $_lPortRaw`"
  	if [ -n "$pUsers" ] ; then
     		PBI_BUILD_USERS="$PBI_BUILD_USERS $pUsers"
  	fi
  	if [ -n "$pGroups" ] ; then
     		PBI_BUILD_GROUPS="$PBI_BUILD_GROUPS $pGroups"
  	fi

	return 0
  fi

  # Lets do old-fashioned build

  # Save any users / groups we need to create later
  local pUsers="`make -V USERS -C $_lPort PORTSDIR=${PORTSDIR}`"
  local pGroups="`make -V GROUPS -C $_lPort PORTSDIR=${PORTSDIR}`"
  if [ -n "$pUsers" ] ; then
     PBI_BUILD_USERS="$PBI_BUILD_USERS $pUsers"
  fi
  if [ -n "$pGroups" ] ; then
     PBI_BUILD_GROUPS="$PBI_BUILD_GROUPS $pGroups"
  fi

  # Parse the pkg deps 
  for _port in `make -C $_lPort PORTSDIR=${PORTSDIR} missing`
  do
    if [ -z "${_port}" ] ; then continue ; fi

    # is this installed?
    pkg info -e ${_port}
    if [ $? -eq 0 ] ; then continue ; fi

    # Not installed, do this one now until we drill down to the base
    do_port_build "${_port}" >&1 2>&1
  done

  echo "Compiling port: ${_lPort}"
  cd ${_lPort}
  make rmconfig
  make clean
  make install
  if [ "$?" != "0" ] ; then
     echo "BUILDERROR1!!"
     sleep 2
     make install
     if [ "$?" != "0" ] ; then
	if [ "$MKDEBUG" = "YES" ] ; then
  	  echo "Failed! Running /bin/sh for debugging, type 'exit' to finish."
  	  /bin/sh
	fi
	make clean
	exit_err "make install of ${PBI_MAKEPORT} failed!"
     fi
  fi
  make clean

};

# Check if the target directory is on ZFS
# Arg1 = The dir to check
# Arg2 = If set to 1, don't dig down to lower level directory
isDirZFS() {
  local _chkDir="$1"
  while :
  do
     # Is this dir a ZFS mount
     mount | grep -w "on $_chkDir " | grep -qw "(zfs," && return 0
        
     # Quit if not walking down
     if [ "$2" = "1" ] ; then return 1 ; fi
        
     if [ "$_chkDir" = "/" ] ; then break ; fi
     _chkDir=`dirname $_chkDir`
  done
 
  return 1
}

# Get the ZFS tank name for a directory
# Arg1 = Directory to check
getZFSTank() {
  local _chkDir="$1"
  _chkdir=${_chkDir%/}
  while :
  do
     zpath=`zfs list | awk -v path="${_chkDir}" '$5 == path { print $1 }'`
     if [ -n "${zpath}" ] ; then
        echo $zpath | cut -f1 -d '/'
        return 0
     fi

     if [ "$_chkDir" = "/" ] ; then return 1 ; fi
     _chkDir=`dirname $_chkDir`
  done

  return 1
}

app_init()
{
  cmd=$1

  # Alias install -> add
  if [ "$cmd" = "install" ] ; then cmd="add" ; fi

  which -s "pbi_${cmd}" 
  if [ $? -ne 0 ] ; then usage_app; fi

  shift
  pbi_${cmd} $*
  exit $?
}

usage_app()
{
   cat <<EOF
usage: `basename $0` <subcommand>

Available sub-commands:

  add
  autobuild
  browser
  create
  delete
  icon
  info
  install
  makeport

EOF
   exit 1
}

# Source our shared PCBSD functions
. /usr/local/share/pcbsd/scripts/functions.sh

# Set the default umask
umask 022

# Main program operation
##############################################################
init_vars
mk_required_dirs

trap exit_trap 1 2 3 9 15

# Figure out which mode we are running in
case `basename ${0}` in
   pbi_add) pbi_add_init "$@" ;;
   pbi_autobuild) pbi_autob_init "$@" ;;
   pbi_browser) pbi_browser_init "$@" ;;
   pbi_create) pbi_create_init "$@" ;;
   pbi_delete) pbi_delete_init "$@" ;;
   pbi_icon) pbi_icon_init "$@" ;;
   pbi_info) pbi_info_init "$@" ;;
   pbi_makeport) pbi_make_init "$@" ;;
   pbi_makeport_chroot) pbi_make_init "$@" ;;
   pbi_makeindex) pbi_makeindex_init "$@" ;;
   app) app_init "$@" ;;
   pbi) app_init "$@" ;;
   pbid) pbid_init "$@" ;;
   *) echo "Error: Called with invalid basename!" ; exit_trap ;;
esac

rm_tmpdir
exit 0
